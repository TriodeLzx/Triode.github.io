<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Triode Field</title>
  
  
  <link href="https://triodelzx.github.io/atom.xml" rel="self"/>
  
  <link href="https://triodelzx.github.io/"/>
  <updated>2024-04-28T10:34:04.609Z</updated>
  <id>https://triodelzx.github.io/</id>
  
  <author>
    <name>Triode_Lzx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>XYCTF2024-疯狂大杂烩！九转功成复现WP</title>
    <link href="https://triodelzx.github.io/2024/04/28/XYCTF2024-%E7%96%AF%E7%8B%82%E5%A4%A7%E6%9D%82%E7%83%A9%EF%BC%81%E4%B9%9D%E8%BD%AC%E5%8A%9F%E6%88%90%E5%A4%8D%E7%8E%B0WP/"/>
    <id>https://triodelzx.github.io/2024/04/28/XYCTF2024-%E7%96%AF%E7%8B%82%E5%A4%A7%E6%9D%82%E7%83%A9%EF%BC%81%E4%B9%9D%E8%BD%AC%E5%8A%9F%E6%88%90%E5%A4%8D%E7%8E%B0WP/</id>
    <published>2024-04-28T10:27:31.000Z</published>
    <updated>2024-04-28T10:34:04.609Z</updated>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p>你能突破九大关卡修成神仙吗？</p><p>hint1：压缩包密码为比赛名称+8位什么来着？忘了。哈哈哈！</p><p>hint2：flag格式：XYCTF{md5(flag)}</p><p>hint3：第三层非夏多，看看交点</p><p>hint4：第六层键盘画图，狼蛛键盘最新版你值得拥有！</p><h1>开头</h1><p>由提示猜测压缩包密码XYCTF20240401</p><h1>炼气</h1><p>第一层是天书加密，用随波逐流就可以解出压缩包密码。</p><p>第二层是一张图片，修改高就可以看到flag的第一部分：</p><blockquote><p>XYCTF{T3e_c0mb1nation_</p></blockquote><h1>筑基</h1><p>第一层是<strong>BubbleBabble</strong>编码，<a href="http://www.hiencode.com/bubble.html">在线解码</a>就能解出压缩包密码。</p><p>第二层是一张图片，010看不出什么东西，用StegSolve通过LSB可以找到一串Base64编码，解码可得flag第二部分：</p><blockquote><p>0f_crypt0_and_</p></blockquote><h1>结丹（全复现）</h1><p>给出一张图片</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281730505.jpg" alt="hint3"></p><p>hint说看交点，可能跟Begin CTF 2023的下一站上岸差不多，四个交点为”-”，三个交点为空格，一个交点为”.”，可以转化为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- .... . ..--.- - .... .. .-. -..</span><br></pre></td></tr></table></figure><p>摩斯密码解码就可以得到压缩包的密码</p><p>打开压缩包发现还有一层压缩包和一个txt，文本文件里面没有有用信息，但是压缩包带密码，用010打开看看，看到末尾有一段附加信息：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281828487.png" alt="image-20240428173027310"></p><p>分析特征，显然是Base64，解码之后可以得到压缩包密码，解压发现里面有一个文本文件，由特征可知是Base32，解码就可以得到flag的第三部分。</p><blockquote><p>misc_1s_re6lly_fun!!</p></blockquote><h1>元婴</h1><p>hint4.txt打开一看发现是base64，解密一看salted，用这个网站解密：<a href="https://www.sojson.com/encrypt_triple_des.html">在线Triple DES加密 | Triple DES解密- 在线工具 (sojson.com)</a>（一个个试出来的），密码是2024.</p><p>拿密码打开压缩包，有个hint.txt和一个db文件，hint内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wqk：1m813onn17o040358p772q37rm137qpnqppqpn38nr704m56n2m9q22po7r05r77</span><br></pre></td></tr></table></figure><p>进行一个凯撒解密就可以得到一个key，</p><p>下面是在52上面找到的一个解密微信聊天数据库的脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> hashlib, hmac, ctypes</span><br><span class="line"></span><br><span class="line">SQLITE_FILE_HEADER = <span class="built_in">bytes</span>(<span class="string">&quot;SQLite format 3&quot;</span>,encoding=<span class="string">&#x27;ASCII&#x27;</span>) + <span class="built_in">bytes</span>(<span class="number">1</span>)<span class="comment">#文件头</span></span><br><span class="line">IV_SIZE = <span class="number">16</span></span><br><span class="line">HMAC_SHA1_SIZE = <span class="number">20</span></span><br><span class="line">KEY_SIZE = <span class="number">32</span></span><br><span class="line">DEFAULT_PAGESIZE = <span class="number">4096</span> <span class="comment">#4048数据 + 16IV + 20 HMAC + 12</span></span><br><span class="line">DEFAULT_ITER = <span class="number">64000</span></span><br><span class="line"><span class="comment">#yourkey</span></span><br><span class="line">password = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;...&quot;</span>.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>))<span class="comment">#这里填入上面求出的key</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;...\\MSG0.db&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:<span class="comment">#这里填入MSG0.db的文件路径</span></span><br><span class="line">    blist = f.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(blist))</span><br><span class="line"></span><br><span class="line">salt = blist[:<span class="number">16</span>]<span class="comment">#微信将文件头换成了盐</span></span><br><span class="line">key = hashlib.pbkdf2_hmac(<span class="string">&#x27;sha1&#x27;</span>, password, salt, DEFAULT_ITER, KEY_SIZE)<span class="comment">#获得Key</span></span><br><span class="line"></span><br><span class="line">first = blist[<span class="number">16</span>:DEFAULT_PAGESIZE]<span class="comment">#丢掉salt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># import struct</span></span><br><span class="line">mac_salt = <span class="built_in">bytes</span>([x^<span class="number">0x3a</span> <span class="keyword">for</span> x <span class="keyword">in</span> salt])</span><br><span class="line">mac_key = hashlib.pbkdf2_hmac(<span class="string">&#x27;sha1&#x27;</span>, key, mac_salt, <span class="number">2</span>, KEY_SIZE)</span><br><span class="line"></span><br><span class="line">hash_mac = hmac.new(mac_key ,digestmod = <span class="string">&#x27;sha1&#x27;</span>)<span class="comment">#用第一页的Hash测试一下</span></span><br><span class="line">hash_mac.update(first[:-<span class="number">32</span>])</span><br><span class="line">hash_mac.update(<span class="built_in">bytes</span>(ctypes.c_int(<span class="number">1</span>)))</span><br><span class="line"><span class="comment"># hash_mac.update(struct.pack(&#x27;=I&#x27;,1))</span></span><br><span class="line"><span class="keyword">if</span> (hash_mac.digest() == first[-<span class="number">32</span>:-<span class="number">12</span>]):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Correct Password&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Wrong Password&#x27;</span>)</span><br><span class="line"></span><br><span class="line">blist = [blist[i:i+DEFAULT_PAGESIZE] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(DEFAULT_PAGESIZE,<span class="built_in">len</span>(blist),DEFAULT_PAGESIZE)]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;...\\ChatMsg.db&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:<span class="comment">#解密后的路径</span></span><br><span class="line">    f.write(SQLITE_FILE_HEADER)<span class="comment">#写入文件头</span></span><br><span class="line">    t = AES.new(key ,AES.MODE_CBC ,first[-<span class="number">48</span>:-<span class="number">32</span>])</span><br><span class="line">    f.write(t.decrypt(first[:-<span class="number">48</span>]))</span><br><span class="line">    f.write(first[-<span class="number">48</span>:])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> blist:</span><br><span class="line">            t = AES.new(key ,AES.MODE_CBC ,i[-<span class="number">48</span>:-<span class="number">32</span>])</span><br><span class="line">            f.write(t.decrypt(i[:-<span class="number">48</span>]))</span><br><span class="line">            f.write(i[-<span class="number">48</span>:])</span><br></pre></td></tr></table></figure><p>用打开数据库的软件打开解密之后的数据库（我用的Dbeaver），在MSG表里面就可以看到flag的第四部分：</p><blockquote><p>L1u_and_K1cky_Mu</p></blockquote><h1>化神（第二部分复现）：</h1><p>hint5给出了一串字符和md5后的结果，进行爆破，爆破出压缩包密码，解压<code>第五层.zip</code> 看到flag.txt里面没有有用的东西.</p><p>serpent.txt文件里有东西，考虑serpent加密，用这个网站<a href="http://serpent.online-domain-tools.com/">Serpent Encryption – Easily encrypt or decrypt strings or files (online-domain-tools.com)</a></p><p>通过文件输入，从头到尾没有密钥，猜测密钥是前面爆破得到的key，解密之后下载下来塞进Cyberchef可以看到</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281828521.png" alt="image-20240428172659005"></p><p>导出为txt并转换编码为UTF-8后可以得到：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281726731.png" alt="image-20240428172642676"></p><p>字数比可以看到的多很多，考虑零宽字符隐写：</p><p>将文本转化为unicode编码后：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281726082.png" alt="image-20240428172606982"></p><p>筛选发现，里面包含零宽unicode字符\u200A,\u200B,\u200C,\u202C,\uFEFF</p><p>用<a href="https://www.mzy0.com/ctftools/zerowidth1/">Unicode Steganography with Zero-Width Characters (mzy0.com)</a>解码即可得出flag的第五部分：</p><blockquote><p>_3re_so_sm4rt!</p></blockquote><h1>炼虚（第二部分复现）：</h1><p>第一层是键盘画图，是一个句子，不确定的字母可以掩码爆破。</p><p>用上面得到的密码打开压缩包，可以看到一个压缩包，一个word文档，一个Excel文档，一个PPT，一个文本文件还有一张图片。除了图片之外，都没有看到有什么有用的，直接用steghide提取一下，发现要密码，发现上面几个文件名称都是数字，倒着来输一遍（98641）就是密码（纯猜谜），提取出来就可以得到flag的第六部分：</p><blockquote><p>In_just_a_few_m1nutes_</p></blockquote><h1>合体</h1><p>第一层UTF-7加维吉尼亚，密钥是字母表。</p><p>解开压缩包可以看到一个图片：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281724825.png" alt="flag"></p><p>就一个八进制，按颜色填数字就行，八进制转换之后就可以得到flag的第七部分：</p><blockquote><p>they_were_thr0ugh!</p></blockquote><h1>大乘</h1><p>这一层的第一部分是一个RSA，显然是p^q泄露，加密代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, getPrime</span><br><span class="line">flag=<span class="string">b&quot;password&#123;xxxxx&#125;&quot;</span></span><br><span class="line">p,q= getPrime(<span class="number">1024</span>),getPrime(<span class="number">1024</span>)</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&quot;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p^q=&quot;</span>,p^q)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n= 22424440693845876425615937206198156323192795003070970628372481545586519202571910046980039629473774728476050491743579624370862986329470409383215065075468386728605063051384392059021805296376762048386684738577913496611584935475550170449080780985441748228151762285167935803792462411864086270975057853459586240221348062704390114311522517740143545536818552136953678289681001385078524272694492488102171313792451138757064749512439313085491407348218882642272660890999334401392575446781843989380319126813905093532399127420355004498205266928383926087604741654126388033455359539622294050073378816939934733818043482668348065680837</span></span><br><span class="line"><span class="string">c= 1400352566791488780854702404852039753325619504473339742914805493533574607301173055448281490457563376553281260278100479121782031070315232001332230779334468566201536035181472803067591454149095220119515161298278124497692743905005479573688449824603383089039072209462765482969641079166139699160100136497464058040846052349544891194379290091798130028083276644655547583102199460785652743545251337786190066747533476942276409135056971294148569617631848420232571946187374514662386697268226357583074917784091311138900598559834589862248068547368710833454912188762107418000225680256109921244000920682515199518256094121217521229357</span></span><br><span class="line"><span class="string">p^q= 14488395911544314494659792279988617621083872597458677678553917360723653686158125387612368501147137292689124338045780574752580504090309537035378931155582239359121394194060934595413606438219407712650089234943575201545638736710994468670843068909623985863559465903999731253771522724352015712347585155359405585892</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>解密代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">100000</span>)<span class="comment">#随便设置，但是不能不设置，增大递归深度限制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pq_high_xor</span>(<span class="params">p=<span class="string">&quot;&quot;</span>, q=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    lp, lq = <span class="built_in">len</span>(p), <span class="built_in">len</span>(q)</span><br><span class="line">    tp0 = <span class="built_in">int</span>(p + (<span class="number">1024</span>-lp) * <span class="string">&quot;0&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    tq0 = <span class="built_in">int</span>(q + (<span class="number">1024</span>-lq) * <span class="string">&quot;0&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    tp1 = <span class="built_in">int</span>(p + (<span class="number">1024</span>-lp) * <span class="string">&quot;1&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    tq1 = <span class="built_in">int</span>(q + (<span class="number">1024</span>-lq) * <span class="string">&quot;1&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tp0 * tq0 &gt; n <span class="keyword">or</span> tp1 * tq1 &lt; n:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> lp == leak_bits:</span><br><span class="line">        pq.append(tp0)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> xor[lp] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">        pq_high_xor(p + <span class="string">&quot;0&quot;</span>, q + <span class="string">&quot;1&quot;</span>)</span><br><span class="line">        pq_high_xor(p + <span class="string">&quot;1&quot;</span>, q + <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pq_high_xor(p + <span class="string">&quot;0&quot;</span>, q + <span class="string">&quot;0&quot;</span>)</span><br><span class="line">        pq_high_xor(p + <span class="string">&quot;1&quot;</span>, q + <span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pq_low_xor</span>(<span class="params">p=<span class="string">&quot;&quot;</span>, q=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    lp, lq = <span class="built_in">len</span>(p), <span class="built_in">len</span>(q)</span><br><span class="line">    tp = <span class="built_in">int</span>(p, <span class="number">2</span>) <span class="keyword">if</span> p <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    tq = <span class="built_in">int</span>(q, <span class="number">2</span>) <span class="keyword">if</span> q <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tp * tq % <span class="number">2</span>**lp != n % <span class="number">2</span>**lp:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> lp == leak_bits:</span><br><span class="line">        pq.append(tp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> xor[-lp-<span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">        pq_low_xor(<span class="string">&quot;0&quot;</span> + p, <span class="string">&quot;1&quot;</span> + q)</span><br><span class="line">        pq_low_xor(<span class="string">&quot;1&quot;</span> + p, <span class="string">&quot;0&quot;</span> + q)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pq_low_xor(<span class="string">&quot;0&quot;</span> + p, <span class="string">&quot;0&quot;</span> + q)</span><br><span class="line">        pq_low_xor(<span class="string">&quot;1&quot;</span> + p, <span class="string">&quot;1&quot;</span> + q)</span><br><span class="line"></span><br><span class="line">n = ...</span><br><span class="line">c = ...</span><br><span class="line">mask = (<span class="number">1</span>&lt;&lt;<span class="number">1024</span>)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">leak_bits = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">leak = ...</span><br><span class="line">xor = <span class="built_in">bin</span>(leak)[<span class="number">2</span>:].zfill(<span class="number">1024</span>)</span><br><span class="line">pq = []</span><br><span class="line">pq_low_xor()</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> pq:</span><br><span class="line">    <span class="keyword">if</span> n % p == <span class="number">0</span>:</span><br><span class="line">        q = n // p</span><br><span class="line">        phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">        d = inverse(<span class="number">65537</span>,phi)</span><br><span class="line">        m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>得到密码解开压缩包，可以见到一个txt，打开看到一堆no和yes，将no替换为0，yes替换为1，通过下述脚本转换为图片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;temp.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    s = f.read()</span><br><span class="line">    pic = Image.new(<span class="string">&quot;L&quot;</span>,(<span class="number">548</span>,<span class="number">72</span>))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">72</span>):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">548</span>):</span><br><span class="line">            <span class="keyword">if</span> s[h * <span class="number">548</span> + w] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                pic.putpixel((w,h),<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pic.putpixel((w,h),<span class="number">255</span>)</span><br><span class="line">    pic.save(<span class="string">&quot;out.png&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281828921.png" alt="out"></p><p>是须弥沙漠文，对字母表换就行，下附字母表</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202404281829364.png" alt="fcd8e8310bde689198d4be3e6b749f15_9129134670435119053"></p><p>换完就可以得到flag的第八部分：</p><blockquote><p>sm3rty0ucando</p></blockquote><h1>渡劫（第二部分复现）</h1><p>这一层的第一部分是一个RSA，很简单，加密代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    a, b = randint(<span class="number">0</span>, <span class="number">2</span>**<span class="number">8</span>), randint(<span class="number">0</span>, <span class="number">2</span>**<span class="number">256</span>)</span><br><span class="line">    <span class="built_in">list</span>.append(a * p + b * q)</span><br><span class="line"></span><br><span class="line">password = <span class="string">b&quot;xxxxx&quot;</span></span><br><span class="line">c = <span class="built_in">pow</span>(bytes_to_long(password), e, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;n = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;c = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">list</span> = &#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#n = 107803636687595025440095910573280948384697923215825513033516157995095253288310988256293799364485832711216571624134612864784507225218094554935994320702026646158448403364145094359869184307003058983513345331145072159626461394056174457238947423145341933245269070758238088257304595154590196901297344034819899810707</span></span><br><span class="line"><span class="comment">#c = 46049806990305232971805282370284531486321903483742293808967054648259532257631501152897799977808185874856877556594402112019213760718833619399554484154753952558768344177069029855164888168964855258336393700323750075374097545884636097653040887100646089615759824303775925046536172147174890161732423364823557122495</span></span><br><span class="line"><span class="comment">#list = [618066045261118017236724048165995810304806699407382457834629201971935031874166645665428046346008581253113148818423751222038794950891638828062215121477677796219952174556774639587782398862778383552199558783726207179240239699423569318, 837886528803727830369459274997823880355524566513794765789322773791217165398250857696201246137309238047085760918029291423500746473773732826702098327609006678602561582473375349618889789179195207461163372699768855398243724052333950197]</span></span><br></pre></td></tr></table></figure><p>解密代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n = ...</span><br><span class="line">c = ...</span><br><span class="line"><span class="built_in">list</span> = [..., ...]</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>):</span><br><span class="line">    <span class="keyword">for</span> a2 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">if</span>(gmpy2.gcd(<span class="built_in">list</span>[<span class="number">0</span>]*a1-<span class="built_in">list</span>[<span class="number">1</span>]*a2,n)!=<span class="number">1</span> <span class="keyword">and</span> gmpy2.gcd(<span class="built_in">list</span>[<span class="number">0</span>]*a1-<span class="built_in">list</span>[<span class="number">1</span>]*a2,n)!=n):</span><br><span class="line">            <span class="built_in">print</span>(gmpy2.gcd(<span class="built_in">list</span>[<span class="number">0</span>]*a1-<span class="built_in">list</span>[<span class="number">1</span>]*a2,n))<span class="comment">#这里求出来是q</span></span><br><span class="line"><span class="comment">#--------part2--------</span></span><br><span class="line">q = ...</span><br><span class="line">p = n // q</span><br><span class="line"><span class="keyword">assert</span> p*q == n</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>解开压缩包就是一个带图片的压缩包和一个txt，txt内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">压缩包里的图片真的有东西吗？不如看向外面</span><br></pre></td></tr></table></figure><p>图片里面确实没有东西，由压缩包名字“我们的小秘密嘿嘿”猜测是oursecret隐写，猜测密码是上面解出来的，尝试发现是正确的，就可以得到flag的第九部分：</p><blockquote><p>_nine_turns?}</p></blockquote><h1>汇总</h1><p>组合之后：</p><blockquote><p>XYCTF{T3e_c0mb1nation_0f_crypt0_and_misc_1s_re6lly_fun!!L1u_and_K1cky_Mu_3re_so_sm4rt!In_just_a_few_m1nutes_they_were_thr0ugh!Sm3rt_y0u_can_do_nine_turns?}</p></blockquote><p>注意，第八段开头大写，然后要按词加下划线得到flag之后要整体用md5加密之后再包上XYCTF{}才是flag。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目描述&lt;/h1&gt;
&lt;p&gt;你能突破九大关卡修成神仙吗？&lt;/p&gt;
&lt;p&gt;hint1：压缩包密码为比赛名称+8位什么来着？忘了。哈哈哈！&lt;/p&gt;
&lt;p&gt;hint2：flag格式：XYCTF{md5(flag)}&lt;/p&gt;
&lt;p&gt;hint3：第三层非夏多，看看交点&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="Write up" scheme="https://triodelzx.github.io/categories/Write-up/"/>
    
    
    <category term="Misc" scheme="https://triodelzx.github.io/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>PicoCTF2024 Crypto部分WP</title>
    <link href="https://triodelzx.github.io/2024/03/29/PicoCTF2024-Crypto%E9%83%A8%E5%88%86WP/"/>
    <id>https://triodelzx.github.io/2024/03/29/PicoCTF2024-Crypto%E9%83%A8%E5%88%86WP/</id>
    <published>2024-03-29T14:02:04.000Z</published>
    <updated>2024-03-29T14:11:27.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>这可能是我打的第一个参与度比较高的国外的CTF，前面四道没什么难度，但是被flag_printer卡了很久，估计一时半会忘不掉这道题.</p><h2 id="interencdec"><a href="#interencdec" class="headerlink" title="interencdec"></a>interencdec</h2><p>签到题</p><p>密文如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YidkM0JxZGtwQlRYdHFhR3g2YUhsZmF6TnFlVGwzWVROclgyZzBOMm8yYXpZNWZRPT0nCg==</span><br></pre></td></tr></table></figure><p>显然是Base64编码，解码得到结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b&#x27;d3BqdkpBTXtqaGx6aHlfazNqeTl3YTNrX2g0N2o2azY5fQ==&#x27;</span><br></pre></td></tr></table></figure><p>去除<strong>b’’</strong>之后进行Base64解码结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpjvJAM&#123;jhlzhy_k3jy9wa3k_h47j6k69&#125;</span><br></pre></td></tr></table></figure><p>进行一次偏移量为7的凯撒解密可以得到flag：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">picoCTF&#123;caesar_d3cr9pt3d_a47c6d69&#125;</span><br></pre></td></tr></table></figure><h2 id="Custom-encryption"><a href="#Custom-encryption" class="headerlink" title="Custom encryption"></a>Custom encryption</h2><p>题目给出加密代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generator</span>(<span class="params">g, x, p</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(g, x) % p<span class="comment">#实际上就是pow(g,x,p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">plaintext, key</span>):</span><br><span class="line">    cipher = []</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> plaintext:</span><br><span class="line">        cipher.append(((<span class="built_in">ord</span>(char) * key*<span class="number">311</span>)))</span><br><span class="line">    <span class="keyword">return</span> cipher</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">p</span>):</span><br><span class="line">    v = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, p + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> p % i == <span class="number">0</span>:</span><br><span class="line">            v = v + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dynamic_xor_encrypt</span>(<span class="params">plaintext, text_key</span>):</span><br><span class="line">    cipher_text = <span class="string">&quot;&quot;</span></span><br><span class="line">    key_length = <span class="built_in">len</span>(text_key)</span><br><span class="line">    <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(plaintext[::-<span class="number">1</span>]):<span class="comment">#将字符串反转后异或加密</span></span><br><span class="line">        key_char = text_key[i % key_length]</span><br><span class="line">        encrypted_char = <span class="built_in">chr</span>(<span class="built_in">ord</span>(char) ^ <span class="built_in">ord</span>(key_char))</span><br><span class="line">        cipher_text += encrypted_char</span><br><span class="line">    <span class="keyword">return</span> cipher_text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">plain_text, text_key</span>):</span><br><span class="line">    p = <span class="number">97</span></span><br><span class="line">    g = <span class="number">31</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_prime(p) <span class="keyword">and</span> <span class="keyword">not</span> is_prime(g):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Enter prime numbers&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    a = randint(p-<span class="number">10</span>, p)</span><br><span class="line">    b = randint(g-<span class="number">10</span>, g)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;a = <span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;b = <span class="subst">&#123;b&#125;</span>&quot;</span>)</span><br><span class="line">    u = generator(g, a, p)</span><br><span class="line">    v = generator(g, b, p)</span><br><span class="line">    key = generator(v, a, p)</span><br><span class="line">    b_key = generator(u, b, p)</span><br><span class="line">    shared_key = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> key == b_key:</span><br><span class="line">        shared_key = key</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Invalid key&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    semi_cipher = dynamic_xor_encrypt(plain_text, text_key)</span><br><span class="line">    cipher = encrypt(semi_cipher, shared_key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;cipher is: <span class="subst">&#123;cipher&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    message = sys.argv[<span class="number">1</span>]</span><br><span class="line">    test(message, <span class="string">&quot;trudeau&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目给出的另一个附件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 89</span><br><span class="line">b = 27</span><br><span class="line">cipher is: [33588, 276168, 261240, 302292, 343344, 328416, 242580, 85836, 82104, 156744, 0, 309756, 78372, 18660, 253776, 0, 82104, 320952, 3732, 231384, 89568, 100764, 22392, 22392, 63444, 22392, 97032, 190332, 119424, 182868, 97032, 26124, 44784, 63444]</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>分析代码可以知道有一个<code>share_key</code>，把它求出来（很简单，不知道他为什么要把<code>pow(a,b,p)</code>包装成一个新的函数）然后通过<code>cipher</code>里面每一个元素除以<code>share_key</code>和311得到一个串，跟<code>text_key</code>进行一个异或（<code>dynamic_xor_encrypt</code>）再对得到的<code>plaintext</code>进行反转。</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>先求<code>share_key</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u = <span class="built_in">pow</span>(g, a, p)</span><br><span class="line">v = <span class="built_in">pow</span>(g, b, p)</span><br><span class="line">key = <span class="built_in">pow</span>(v, a, p)</span><br><span class="line">b_key = <span class="built_in">pow</span>(u, b, p)</span><br><span class="line"><span class="keyword">if</span> key == b_key:</span><br><span class="line">    shared_key = key</span><br></pre></td></tr></table></figure><p>求出<code>share_key</code>之后就可以将<code>cipher</code>除以<code>share_key</code>和311得到一个串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temp = [x//shared_key//<span class="number">311</span> <span class="keyword">for</span> x <span class="keyword">in</span> cipher]</span><br></pre></td></tr></table></figure><p>将<code>temp</code>与<code>text_key</code>进行一个异或，其中<code>text_key=&quot;trudeau&quot;</code>得到一字符串后反转就可以得到flag：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">text_key = <span class="string">&quot;trudeau&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(temp)):</span><br><span class="line">    s += <span class="built_in">chr</span>(<span class="built_in">ord</span>(temp[i])^<span class="built_in">ord</span>(text_key[i%<span class="built_in">len</span>(text_key)]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>总体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="number">97</span></span><br><span class="line">g = <span class="number">31</span></span><br><span class="line">a = <span class="number">89</span></span><br><span class="line">b = <span class="number">27</span></span><br><span class="line">cipher = [<span class="number">33588</span>, <span class="number">276168</span>, <span class="number">261240</span>, <span class="number">302292</span>, <span class="number">343344</span>, <span class="number">328416</span>, <span class="number">242580</span>, <span class="number">85836</span>, <span class="number">82104</span>, <span class="number">156744</span>, <span class="number">0</span>, <span class="number">309756</span>, <span class="number">78372</span>, <span class="number">18660</span>, <span class="number">253776</span>, <span class="number">0</span>, <span class="number">82104</span>, <span class="number">320952</span>, <span class="number">3732</span>, <span class="number">231384</span>, <span class="number">89568</span>, <span class="number">100764</span>, <span class="number">22392</span>, <span class="number">22392</span>, <span class="number">63444</span>, <span class="number">22392</span>, <span class="number">97032</span>, <span class="number">190332</span>, <span class="number">119424</span>, <span class="number">182868</span>, <span class="number">97032</span>, <span class="number">26124</span>, <span class="number">44784</span>, <span class="number">63444</span>]</span><br><span class="line"></span><br><span class="line">u = <span class="built_in">pow</span>(g, a, p)</span><br><span class="line">v = <span class="built_in">pow</span>(g, b, p)</span><br><span class="line">key = <span class="built_in">pow</span>(v, a, p)</span><br><span class="line">b_key = <span class="built_in">pow</span>(u, b, p)</span><br><span class="line"><span class="keyword">if</span> key == b_key:</span><br><span class="line">    shared_key = key</span><br><span class="line"></span><br><span class="line">temp = [<span class="built_in">chr</span>(x//shared_key//<span class="number">311</span>) <span class="keyword">for</span> x <span class="keyword">in</span> cipher]</span><br><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">text_key = <span class="string">&quot;trudeau&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(temp)):</span><br><span class="line">    s += <span class="built_in">chr</span>(<span class="built_in">ord</span>(temp[i])^<span class="built_in">ord</span>(text_key[i%<span class="built_in">len</span>(text_key)]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>运行可得flag：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">picoCTF&#123;custom_d2cr0pt6d_dc499538&#125;</span><br></pre></td></tr></table></figure><h2 id="C3"><a href="#C3" class="headerlink" title="C3"></a>C3</h2><p>加密代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">chars = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> fileinput <span class="keyword">import</span> <span class="built_in">input</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">input</span>():</span><br><span class="line">  chars += line</span><br><span class="line"></span><br><span class="line">lookup1 = <span class="string">&quot;\n \&quot;#()*+/1:=[]abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line">lookup2 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrst&quot;</span></span><br><span class="line"></span><br><span class="line">out = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">prev = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> chars:</span><br><span class="line">  cur = lookup1.index(char)</span><br><span class="line">  out += lookup2[(cur - prev) % <span class="number">40</span>]</span><br><span class="line">  prev = cur</span><br><span class="line"></span><br><span class="line">sys.stdout.write(out)</span><br></pre></td></tr></table></figure><p>题目给出的另外一个附件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DLSeGAGDgBNJDQJDCFSFnRBIDjgHoDFCFtHDgJpiHtGDmMAQFnRBJKkBAsTMrsPSDDnEFCFtIbEDtDCIbFCFtHTJDKerFldbFObFCFtLBFkBAAAPFnRBJGEkerFlcPgKkImHnIlATJDKbTbFOkdNnsgbnJRMFnRBNAFkBAAAbrcbTKAkOgFpOgFpOpkBAAAAAAAiClFGIPFnRBaKliCgClFGtIBAAAAAAAOgGEkImHnIl</span><br></pre></td></tr></table></figure><p>可以知道附件是<code>chars</code>加密得到的，分析代码后写出解密代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chipher = <span class="string">&#x27;DLSeGAGDgBNJDQJDCFSFnRBIDjgHoDFCFtHDgJpiHtGDmMAQFnRBJKkBAsTMrsPSDDnEFCFtIbEDtDCIbFCFtHTJDKerFldbFObFCFtLBFkBAAAPFnRBJGEkerFlcPgKkImHnIlATJDKbTbFOkdNnsgbnJRMFnRBNAFkBAAAbrcbTKAkOgFpOgFpOpkBAAAAAAAiClFGIPFnRBaKliCgClFGtIBAAAAAAAOgGEkImHnIl&#x27;</span></span><br><span class="line">lookup1 = <span class="string">&quot;\n \&quot;#()*+/1:=[]abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line">lookup2 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrst&quot;</span></span><br><span class="line">chars = <span class="string">&#x27;&#x27;</span></span><br><span class="line">prev = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chipher)):</span><br><span class="line">    cur = lookup2.index(chipher[i])</span><br><span class="line">    chars += lookup1[(cur + prev)%<span class="number">40</span>]</span><br><span class="line">    prev = (cur + prev)%<span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(chars)</span><br></pre></td></tr></table></figure><p>运行代码可得：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#asciiorder</span></span><br><span class="line"><span class="comment">#fortychars</span></span><br><span class="line"><span class="comment">#selfinput</span></span><br><span class="line"><span class="comment">#pythontwo</span></span><br><span class="line"></span><br><span class="line">chars = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> fileinput <span class="keyword">import</span> <span class="built_in">input</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">input</span>():</span><br><span class="line">    chars += line</span><br><span class="line">b = <span class="number">1</span> / <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chars)):</span><br><span class="line">    <span class="keyword">if</span> i == b * b * b:</span><br><span class="line">        <span class="built_in">print</span> chars[i] <span class="comment">#prints</span></span><br><span class="line">        b += <span class="number">1</span> / <span class="number">1</span></span><br></pre></td></tr></table></figure><p>会发现解出来是一串缺少参数<code>chars</code>内容的代码，猜测这里的<code>chars</code>就是上面求解出来的<code>chars</code>，拼接上一条代码再进行修改后得到如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">chipher = <span class="string">&#x27;DLSeGAGDgBNJDQJDCFSFnRBIDjgHoDFCFtHDgJpiHtGDmMAQFnRBJKkBAsTMrsPSDDnEFCFtIbEDtDCIbFCFtHTJDKerFldbFObFCFtLBFkBAAAPFnRBJGEkerFlcPgKkImHnIlATJDKbTbFOkdNnsgbnJRMFnRBNAFkBAAAbrcbTKAkOgFpOgFpOpkBAAAAAAAiClFGIPFnRBaKliCgClFGtIBAAAAAAAOgGEkImHnIl&#x27;</span></span><br><span class="line">lookup1 = <span class="string">&quot;\n \&quot;#()*+/1:=[]abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line">lookup2 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrst&quot;</span></span><br><span class="line">chars = <span class="string">&#x27;&#x27;</span></span><br><span class="line">prev = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chipher)):</span><br><span class="line">    cur = lookup2.index(chipher[i])</span><br><span class="line">    chars += lookup1[(cur + prev)%<span class="number">40</span>]</span><br><span class="line">    prev = (cur + prev)%<span class="number">40</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">1</span> / <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chars)):</span><br><span class="line">    <span class="keyword">if</span> i == b * b * b:</span><br><span class="line">        <span class="built_in">print</span>(chars[i],end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        b += <span class="number">1</span> / <span class="number">1</span></span><br></pre></td></tr></table></figure><p>运行得到的字符串包裹上<code>picoCTF&#123;&#125;</code>即可得到flag：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">picoCTF&#123;adlibs&#125;</span><br></pre></td></tr></table></figure><h2 id="rsa-oracle"><a href="#rsa-oracle" class="headerlink" title="rsa_oracle"></a>rsa_oracle</h2><p>这道题考点较多，但是算是模板题，所以难度不算高.</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>首先题目给了个预言机（Oracle），通过交互我们可以发现可以通过这个Oracle对一些东西进行加密或者解密，而文件中给出了一个password.enc文件，从题目描述中的“<strong>After some intensive reconassainance they found out that the bank has an oracle that was used to encrypt the password</strong>”可以知道password.enc里面的数据是通过Oracle中内置的RSA的参数进行加密的，但是我们并不能将password.enc的数据直接丢进Oracle里面得到password，故我们考虑使用选择密文攻击得到password。得到password之后，我们通过<strong>hint2：OpenSSL can be used to decrypt the message. e.g <code>openssl enc -aes-256-cbc -d ...</code></strong> （或者通过message.enc里面的格式）可以知道需要通过OpenSSL解密message.enc得到flag，而密码就是password.enc解密得到的。</p><h3 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h3><h4 id="第一步：先通过选择明文攻击得到Oracle中的RSA加密的参数"><a href="#第一步：先通过选择明文攻击得到Oracle中的RSA加密的参数" class="headerlink" title="第一步：先通过选择明文攻击得到Oracle中的RSA加密的参数"></a>第一步：先通过选择明文攻击得到Oracle中的RSA加密的参数</h4><p>由RSA的原理，我们可以得到以下式子：</p><script type="math/tex; mode=display">2^e\equiv c_2\pmod{n}\\4^e\equiv c_4\pmod{n}\\8^e\equiv c_8\pmod{n}</script><p>可得：</p><script type="math/tex; mode=display">c_2^2\equiv c_4\pmod{n}\\c_2^3\equiv c_8\pmod{n}</script><p>即：</p><script type="math/tex; mode=display">c_2^2-c_4=k_1n\\c_2^3-c_8=k_2n</script><p>在一般情况下，有$(c_2^2-c_4,c_2^3-c_8)=n$</p><p>自此，我们得到了$n$，现在要得到$e$，猜测$e$小于$100000$，使用上面求出的$c_2$（或者$c_4,c_8$）进行爆破，就得到了$e$。</p><p>该步代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">io = remote(<span class="string">&quot;地址&quot;</span>,端口)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get pow(2,e,n)</span></span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="built_in">chr</span>(<span class="number">2</span>).encode())</span><br><span class="line">data = ((io.recv().split(<span class="string">b&#x27; &#x27;</span>)[<span class="number">11</span>]).split(<span class="string">b&#x27;\n&#x27;</span>)[<span class="number">0</span>]).decode()</span><br><span class="line">c2 = <span class="built_in">int</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get pow(4,e,n)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="built_in">chr</span>(<span class="number">4</span>).encode())</span><br><span class="line">data = ((io.recv().split(<span class="string">b&#x27; &#x27;</span>)[<span class="number">11</span>]).split(<span class="string">b&#x27;\n&#x27;</span>)[<span class="number">0</span>]).decode()</span><br><span class="line">c4 = <span class="built_in">int</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get pow(8,e,n)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">data = io.recv()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">io.sendline(<span class="built_in">chr</span>(<span class="number">8</span>).encode())</span><br><span class="line">data = ((io.recv().split(<span class="string">b&#x27; &#x27;</span>)[<span class="number">11</span>]).split(<span class="string">b&#x27;\n&#x27;</span>)[<span class="number">0</span>]).decode()</span><br><span class="line">c8 = <span class="built_in">int</span>(data)</span><br><span class="line"></span><br><span class="line">n = gmpy2.gcd(c2**<span class="number">2</span>-c4,c2**<span class="number">3</span>-c8)</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(<span class="number">2</span>,e,n)==c2:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><h4 id="第二步：通过选择密文攻击得到password（OpenSSL中用于解密的key）"><a href="#第二步：通过选择密文攻击得到password（OpenSSL中用于解密的key）" class="headerlink" title="第二步：通过选择密文攻击得到password（OpenSSL中用于解密的key）"></a>第二步：通过选择密文攻击得到password（OpenSSL中用于解密的key）</h4><p>由于不能直接解密password（后面将里面的数记为$c$），而从一般通过Oracle选择密文攻击的题目，我们可以知道他应该也不能解密$c+kn,k\in Z$，我们考虑通过解密$c*s^e\ mod\ n$来得到我们需要的东西。</p><p>解密之后可以得到$s$倍的$m$（这里$m$就是解密后的<code>password</code>），乘上$inv(s,n)$再模$n$（这里$inv(a,b)$表示$a$模$b$的乘法逆元）就可以还原出<code>password</code>了（需要<code>long_to_bytes</code>）</p><p>核心代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.sendline(<span class="built_in">str</span>(c*<span class="built_in">pow</span>(<span class="number">2</span>,e,n)%n).encode())</span><br></pre></td></tr></table></figure><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>通过OpenSSL对message.enc通过<code>aes_256_cbc</code>算法进行解密，命令大致如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl enc <span class="literal">-aes-256-cbc</span> <span class="literal">-d</span> <span class="operator">-in</span> (这里是message.enc的路径) <span class="literal">-out</span> flag.txt <span class="literal">-k</span> (这里是password)</span><br></pre></td></tr></table></figure><p>就可以得到flag了.</p><h2 id="flag-printer"><a href="#flag-printer" class="headerlink" title="flag_printer"></a>flag_printer</h2><p>算法优化题，卡了好久，感觉这题不应该出现在Cryptography里面.</p><p>题目给出了一个30.8MB的文本文件，里面有1769611组数，还给出了一个python源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> galois</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">MOD = <span class="number">7514777789</span></span><br><span class="line"></span><br><span class="line">points = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;encoded.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read().strip().split(<span class="string">&#x27;\n&#x27;</span>):</span><br><span class="line">    x, y = line.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    points.append((<span class="built_in">int</span>(x), <span class="built_in">int</span>(y)))</span><br><span class="line"></span><br><span class="line">GF = galois.GF(MOD)</span><br><span class="line"></span><br><span class="line">matrix = []</span><br><span class="line">solution = []</span><br><span class="line"><span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">    x, y = point</span><br><span class="line">    solution.append(GF(y % MOD))</span><br><span class="line"></span><br><span class="line">    row = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points)):</span><br><span class="line">        row.append(GF(x**i%MOD))</span><br><span class="line"></span><br><span class="line">    matrix.append(GF(row))</span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;output.bmp&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>).write(<span class="built_in">bytearray</span>(np.linalg.solve(GF(matrix), GF(solution)).tolist()[:-<span class="number">1</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由代码可以知道我们需要求解如下方程：</p><script type="math/tex; mode=display">\left[\begin{matrix}x_0^0&x_0^1&x_0^2&\cdots&x_0^{n-1}\\x_1^0&x_1^1&x_1^2&\cdots&x_1^{n-1}\\x_2^0&x_2^1&x_2^2&\cdots&x_2^{n-1}\\\vdots&\vdots&\vdots&\ddots&\vdots\\x_{n-1}^0&x_{n-1}^1&x_{n-1}^2&\cdots&x_{n-1}^{n-1}\\\end{matrix}\right]\left[\begin{matrix}\alpha_0\\\alpha_1\\\alpha_2\\\vdots\\\alpha_{n-1}\end{matrix}\right]=\left[\begin{matrix}y_0\\y_1\\y_2\\\vdots\\y_{n-1}\end{matrix}\right]</script><p>可以看到，左式的$n\times n$矩阵是一个范德蒙德矩阵，所以优先考虑范德蒙德方程组求解，找到<strong>Björck-Pereyra算法</strong>，后面发现在Python中需要分配11.4TB的内存，并不能解决问题。</p><p>再观察矩阵可以发现对于任意$x_i(i=0,1,2,\cdots,n-1)$，有：$\alpha_0x_i^0+\alpha_1x_i^1+\alpha_2x_i^2+\cdots+\alpha_{n-1}x_i^{n-1}=y_i$</p><p>可以知道，这显然可以利用拉格朗日插值法，得到的函数应为：$f(x)=\alpha_0x^0+\alpha_1x^1+\alpha_2x^2+\cdots+\alpha_{n-1}x^{n-1}$</p><p>但是一般的拉格朗日插值法时间复杂度太高，不能达到我想要的效果（实际上如果是硬跑的话还是可以跑出flag的），故考虑FFT（快速傅里叶变换），但是可惜的是我对算法的学习不深，并不知道怎么写FFT.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;感想&quot;&gt;&lt;a href=&quot;#感想&quot; class=&quot;headerlink&quot; title=&quot;感想&quot;&gt;&lt;/a&gt;感想&lt;/h2&gt;&lt;p&gt;这可能是我打的第一个参与度比较高的国外的CTF，前面四道没什么难度，但是被flag_printer卡了很久，估计一时半会忘不掉这道题.&lt;/p</summary>
      
    
    
    
    
    <category term="Crypto" scheme="https://triodelzx.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>向量空间（Vector Space）学习笔记</title>
    <link href="https://triodelzx.github.io/2024/03/24/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4%EF%BC%88Vector-Space%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://triodelzx.github.io/2024/03/24/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4%EF%BC%88Vector-Space%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-03-24T15:26:39.000Z</published>
    <updated>2024-03-24T15:32:56.535Z</updated>
    
    <content type="html"><![CDATA[<p>由于近期高等代数课程正在讲向量空间，所以想着结合一下高中对于向量空间的学习整理一下一些知识点和笔记。</p><p><strong>参考书籍：《高等代数（第五版）》（北京大学数学系前代数小组 编，高等教育出版社）（以下简称北大版），《高等代数（第五版）》（张禾瑞、郝鈵新 编，高等教育出版社）（以下简称北师大版）</strong></p><h2 id="向量空间的定义"><a href="#向量空间的定义" class="headerlink" title="向量空间的定义"></a>向量空间的定义</h2><p>设$V$是一个非空集合，$F$为一个数域.在集合$V$的元素之间定义一代数运算，称为<strong>加法</strong>，即给出一个法则，对于$V$中任意两个元素$\pmb{\alpha}$与$\pmb{\beta}$，在$V$中都有唯一的一个元素$\pmb{\gamma}$，称为$\pmb{\alpha}$与$\pmb{\beta}$的和，记为$\pmb{\gamma}=\pmb{\alpha}+\pmb{\beta}$，在数域$F$与集合$V$的元素之间还定义了一种运算，称为数量乘法，即对于数域$F$中任一数$k$与$V$中任意元素$\pmb{\alpha}$，在$V$中都有唯一的一个元素$\pmb{\delta}$与它们对应，称为$k$与$\pmb{\alpha}$的<strong>数量乘积</strong>（简称<strong>数乘</strong>），记为$\pmb{\delta}=k\pmb{\alpha}$.若加法与数乘满足下述规则，那么$V$称为数域$P$上的<strong>向量空间</strong>（或称<strong>线性空间</strong>）（向量空间或集合$V$中的元素用小写黑体希腊字母表示，数域中元素用小写拉丁字母表示）：</p><script type="math/tex; mode=display">\begin{flalign}&(1)\ \pmb{\alpha}+\pmb{\beta}=\pmb{\beta}+\pmb{\alpha};\\&(2)\ (\pmb{\alpha}+\pmb{\beta})+\pmb{\gamma}=\pmb{\alpha}+(\pmb{\beta}+\pmb{\gamma});\\&(3)\ 在V中有一元素\pmb{0}，对于V中任一元素\pmb{\alpha} 都有\ \pmb{0}+\pmb{\alpha}=\pmb{\alpha}\\&(具有该性质的元素\pmb{0}称为V的零元素);\\&(4)\ 对于V中每一元素\pmb{\alpha} ,都有V中的元素\pmb{\beta},使得\ \pmb{\alpha}+\pmb{\beta}=0\\&(\pmb{\beta} 称为\pmb{\alpha} 的负元素);\\&(5)1\pmb{\alpha} = \pmb{\alpha};\\&(6)k(l\pmb{\alpha})=(kl)\pmb{\alpha}\ (k,l\in F,下同);\\&(7)(k+l)\pmb{\alpha} = k\pmb{\alpha}+l\pmb{\alpha};\\&(8)k(\pmb{\alpha}+\pmb{\beta})=k\pmb{\alpha}+k\pmb{\beta}.\end{flalign}</script><h2 id="向量空间的一些简单的性质"><a href="#向量空间的一些简单的性质" class="headerlink" title="向量空间的一些简单的性质"></a>向量空间的一些简单的性质</h2><p>1.零元素是唯一的.</p><p>2.负元素是唯一的.</p><p>3.$0\pmb{\alpha}=\pmb{0},k\pmb{0}=\pmb{0},(-1)\pmb{\alpha}=-\pmb{\alpha}$</p><p>4.若$k\pmb{\alpha}=\pmb{0}$，则有$k=0$或$\pmb{\alpha}=\pmb{0}$</p><h2 id="子空间"><a href="#子空间" class="headerlink" title="子空间"></a>子空间</h2><p><strong>子空间的定义：</strong>令$W$是数域$F$上向量空间$V$的一个非空子集.若$W$对于$V$的加法以及标量与向量的乘法来说是封闭的，那么就称$W$是$V$的一个<strong>子空间</strong>.</p><p><strong>定理1：</strong>数域$F$上向量空间$V$的一个非空子集$W$是$V$的一个子空间，当且仅当对于任意$a,b\in F,\pmb{\alpha}$及任意$\pmb{\beta}\in W$，都有$a\pmb{\alpha}+b\pmb{\beta}\in W$</p><h2 id="子空间的和与直和"><a href="#子空间的和与直和" class="headerlink" title="子空间的和与直和"></a>子空间的和与直和</h2><p><strong>子空间和的定义：</strong>设$W_1,W_2$为向量空间$V$的两个子空间.那么$W_1,W_2$的<strong>和</strong>是指由所有能表示为$\pmb{\alpha_1}+\pmb{\alpha_2}$，而$\pmb{\alpha_1}\in V_1,\pmb{\alpha_2}\in V_2$的向量组成的子集合，记作$V_1+V_2$.</p><p>在子空间的和中，有一种特殊的情形，被称为<strong>直和(direct sum)</strong>，定义如下：</p><p><strong>直和的定义：</strong>设设$W_1,W_2$为向量空间$V$的两个子空间，若和$W_1+W_2$中每个向量$\pmb{\alpha}$的分解式$\pmb{\alpha}=\pmb{\alpha_1}+\pmb{\alpha_2}\ (\pmb{\alpha_1}\in V_1,\pmb{\alpha_2}\in V_2)$是唯一的，则称这个和为<strong>直和</strong>，记为$V_1\oplus V_2$.</p><p><strong>余子空间的定义：</strong>设$W$为向量空间$V$的一个子空间，若对于$V$的一个子空间$W’$，满足$W\oplus W’=V$，则称$W’$是$W$的一个<strong>余子空间</strong>.</p><p>由定义我们可以知道：</p><p>（1）和$V_1+V_2$是直和的充分必要条件为等式$\pmb{\alpha_1}+\pmb{\alpha_2}=\pmb{0}$(其中$\pmb{\alpha_1}\in V_1,\pmb{\alpha_2}\in V_2)$只有在$\pmb{\alpha_1},\pmb{\alpha_2}$全为零向量时才成立；</p><p>（2）和$V_1+V_2$是直和的充分必要条件为$V_1\cap V_2=\{\pmb{0}\}$；</p><h2 id="向量的线性相关性、向量组的等价及向量组的极大线性无关组"><a href="#向量的线性相关性、向量组的等价及向量组的极大线性无关组" class="headerlink" title="向量的线性相关性、向量组的等价及向量组的极大线性无关组"></a>向量的线性相关性、向量组的等价及向量组的极大线性无关组</h2><p> <strong>线性组合的定义：</strong>设$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$是向量空间$V$的$r$个向量，$a_1,a_2,\cdots,a_r$是数域$F$中任意$r$个数.我们将和$\pmb{\alpha}=a_1\pmb{\alpha_1}+a_2\pmb{\alpha_2}+\cdots+a_r\pmb{\alpha_r}$称为向量$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$的一个<strong>线性组合</strong>，而称向量$\pmb{\alpha}$被$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$<strong>线性表示</strong>.</p><p><strong>线性相关的定义：</strong>设$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$是向量空间$V$的$r$个向量，若存在$F$中不全为零的数$a_1,a_2,\cdots,a_r$，使得：$a_1\pmb{\alpha_1}+a_2\pmb{\alpha_2}+\cdots+a_r\pmb{\alpha_r}=\pmb{0}$，则称$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$线性相关.</p><p>若向量组不线性相关，则称它们<strong>线性无关</strong>.</p><p><strong>向量组等价的定义：</strong>设$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\}$和$\{\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s}\}$是向量空间$V$的两个向量组. 若每一$\pmb{\alpha_i}$都可以由$\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s}$线性表示，而每一$\pmb{\beta_j}$也可以由$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$线性表示，那么就说这两个向量组<strong>等价</strong>.</p><p><strong>极大线性无关组的定义：</strong>对于向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}\}$的一个部分向量组$\{\pmb{\alpha_{i_1}},\pmb{\alpha_{i_2}},\cdots,\pmb{\alpha_{i_r}}\}$，若$\pmb{\alpha_{i_1}},\pmb{\alpha_{i_2}},\cdots,\pmb{\alpha_{i_r}}$线性无关且对于每一$\pmb{\alpha_j}\ (j=1\cdots,n)$都可以由$\pmb{\alpha_{i_1}},\pmb{\alpha_{i_2}},\cdots,\pmb{\alpha_{i_r}}$线性表示，则称部分向量组$\{\pmb{\alpha_{i_1}},\pmb{\alpha_{i_2}},\cdots,\pmb{\alpha_{i_r}}\}$为$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}\}$的一个<strong>极大线性无关部分组</strong>（简称<strong>极大线性无关组</strong>）.</p><p>实际上，在解析几何中，我们已经接触过线性相关与线性无关的概念，在高等代数中，将“向量”这一概念泛化之后，我们可以知道：在向量空间$F\left[x\right]$（数域$F$中一元多项式环）中，对于任意非负整数$n$，有$1,x,x^2,\cdots,x^n$线性无关.</p><p>下面是几个有用的定理：</p><p><strong>定理2：</strong>若向量$\pmb{\gamma}$可以由$\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_r}$线性表示，而每一$\pmb{\beta_i}$又可以由$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$线性表示，那么$\pmb{\gamma}$可以被$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$线性表示.</p><p><strong>定理3：</strong>若向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\}$线性无关，而向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r},\pmb{\beta}\}$线性相关，则$\pmb{\beta}$可以由$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$线性表示.</p><p><strong>定理4：</strong>向量$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}(r\ge2)$线性相关，当且仅当其中某一个向量是其余向量的线性组合.</p><p><strong>定理5（替换定理）：</strong>设向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\}$线性无关，并且每一$\pmb{\alpha_i}$都可以由向量组$\{\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s}\}$线性表示.那么$r\le s$，且必要时可以对$\{\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s}\}$中向量重新编号，使得用$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}$替换$\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_r}$后，所得的向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r},\pmb{\beta_{r+1}},\pmb{\beta_{r+2}},\cdots,\pmb{\beta_s}\}$与$\{\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s}\}$等价.</p><p><strong>替换定理推论1：</strong>两个等价的线性无关的向量组含有相同个数的向量.</p><p><strong>替换定理推论2：</strong>等价的向量组的极大无关组含有相同个数的向量，特别的，一个向量组的任意两个极大无关组含有相同个数的向量.</p><p>下面是一个求$F^n$中列向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\}$的一个极大线性无关组的方法：</p><p>（1）首先将列向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\}$拼接为一个矩阵$\pmb{A}=\left(\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\right)$，</p><p>（2）将其化为行最简形式，并得出矩阵$\pmb{A}$的秩$r(\pmb{A})$，</p><p>（3）从中挑选非零数最少的$r(\pmb{A})$个列向量（一般只有一个元素是$1$而其余是$0$），这些变换后的列向量对应的原向量组成的向量组即为向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\}$的一个极大线性无关组.</p><p>举个例子：</p><p>已知向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\pmb{\alpha_3},\pmb{\alpha_4},\pmb{\alpha_5}\}$，其中$\pmb{\alpha_1}=(1,1,2,3)^T,\pmb{\alpha_2}=(-1,-1,1,1)^T,\pmb{\alpha_3}=(1,3,3,5)^T,\pmb{\alpha_4}=(4,-2,5,6)^T, \pmb{\alpha_5}=(-3,-1,-5,-7)$，求这个向量组的一个极大线性无关组.</p><script type="math/tex; mode=display">\begin{flalign}解:&将这5个向量拼接为一个矩阵如下:\\&\left(\pmb{\alpha_1},\pmb{\alpha_2},\pmb{\alpha_3},\pmb{\alpha_4},\pmb{\alpha_5}\right)=\left(\begin{matrix}1&-1&1&4&-3\\1&-1&3&-2&-1\\2&1&3&5&-5\\3&1&5&6&-7\end{matrix}\right)→\left(\begin{matrix}1&0&0&7&-4\\0&1&0&0&0\\0&0&1&-3&1\\0&0&0&0&0\end{matrix}\right)\\&取第1，2，3列向量对应的原向量即\pmb{\alpha_1},\pmb{\alpha_2},\pmb{\alpha_3}，可得到向量组\{\pmb{\alpha_1},\pmb{\alpha_2},\pmb{\alpha_3},\pmb{\alpha_4},\pmb{\alpha_5}\}的一个极大线性无关组为\{\pmb{\alpha_1},\pmb{\alpha_2},\pmb{\alpha_3}\}.\end{flalign}</script><h2 id="基和维数"><a href="#基和维数" class="headerlink" title="基和维数"></a>基和维数</h2><p><strong>生成元和生成子空间的定义：</strong>设$V$为数域$F$上一个向量空间，$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}\in V$，由$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}$的一切线性组合所成的集合显然是$V$的一个子空间，称这个子空间为<strong>由$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}$所生成的子空间</strong>，并用符号$\mathscr{L}(\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n})$表示.向量$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}$叫做这个子空间的一组<strong>生成元</strong>.</p><p><strong>基的定义：</strong>设$V$是数域$F$上一个向量空间.对于$V$中一向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}\}$，若$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}$线性无关且$V$中的每一向量都可以被$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}$线性表示，则称向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}\}$为$V$的一个<strong>基</strong>.</p><p>根据定义，我们很容易可以知道向量空间$V$的一个基就是$V$的一组线性无关的生成元.</p><p>而对数域$F^n$中的$n$个向量：$\pmb{\varepsilon_i}=(0,\cdots,0,1,0,\cdots,0)$，这里$\pmb{\varepsilon_i}$除第$i$为$1$外，其余位置元素均为零，显然向量组$\{\pmb{\varepsilon_1},\pmb{\varepsilon_2},\cdots,\pmb{\varepsilon_n}\}$是$F^n$的一个基，这个基称为$F^n$的<strong>标准基</strong>（或称<strong>标准正交基</strong>）.</p><p><strong>维的定义：</strong>一个向量空间$V$的基所含向量个数称为$V$的<strong>维数</strong>，记作$\dim V$，特别的，我们定义<strong>零空间</strong>的维数为$0$.</p><p>几个常见向量空间的维数：</p><p>（1）$F^n$的维数为$n$；</p><p>（2）$F$上一切$m×n$的矩阵所成的向量空间的维数为$mn$；</p><p>（3）$F[x]$是无限维的.</p><p>下面是关于基和维数的几个定理：</p><p><strong>定理6：</strong>设$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}\}$是向量空间$V$的一个基.那么$V$中的每一个向量可以<strong>唯一</strong>地被表成基向量$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_n}$的线性组合.</p><p><strong>定理7：</strong>$n$维向量空间中任意多于$n$个向量一定线性相关.</p><p><strong>定理8：</strong>设$\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}\in V$为$n$维向量空间$V$中一组线性无关向量.那么总可以添加$n-r$个向量$\pmb{\alpha_{r+1}},\cdots,\pmb{\alpha_n}$使得$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r},\pmb{\alpha_{r+1}},\cdots,\pmb{\alpha_n}\}$作成$V$的一组基.特别的，$n$维向量空间中任意$n$个线性无关的向量都可以取作基.</p><p><strong>定理9（维数定理）：</strong>设$W_1$和$W_2$都是数域$F$上向量空间$V$的有限维子空间.那么$W_1+W_2$也是有限维的，且</p><script type="math/tex; mode=display">\dim(W_1+W_2)=\dim W_1+\dim W_2-\dim(W_1\cap W_2)</script><p>对于向量空间$V_1,V_2$，$V_1+V_2$的基即为$V_1,V_2$的生成元构成的向量组的一个极大线性无关组.</p><p>在对$n$维列向量组成的向量空间$W_1,W_2$使用维数定理时，我们常常需要求$W_1+W_2$与$W_1\cap W_2$，下面是求它们的方法：</p><p>设$W_1=\mathscr{L}(\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r}),W_2=\mathscr{L}(\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s})$</p><p>（1）将$W_1,W_2$的生成元拼接为矩阵</p><script type="math/tex; mode=display">\pmb{A}=(\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r},\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s})</script><p>（2）求出向量组$\{\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r},\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s}\}$的一个极大线性无关组，设为$\{\pmb{\gamma_1},\pmb{\gamma_2},\cdots,\pmb{\gamma_t}\}$，则$W_1+W_2=\mathscr{L}(\pmb{\gamma_1},\pmb{\gamma_2},\cdots,\pmb{\gamma_t})$，且$\dim (W_1+W_2)=t$</p><p>（3）求出矩阵$(\pmb{\alpha_1},\pmb{\alpha_2},\cdots,\pmb{\alpha_r},\pmb{\beta_1},\pmb{\beta_2},\cdots,\pmb{\beta_s})$所表示的齐次线性方程组的<strong>基础解系</strong>$\{\pmb{\delta_1},\pmb{\delta_2},\cdots,\pmb{\delta_u}\}$，那么我们可以得到$W_1\cap W_2=\mathscr{L}(\pmb{\delta_1},\pmb{\delta_2},\cdots,\pmb{\delta_u})$，且有$\dim (W_1\cap W_2)=u$.</p><p>（基础解系相关定义将会在后面给出）</p><p>显然有$t=r(\pmb{A}),\dim W_1=r,\dim W_1=s$，而由基础解系的概念，显然有$u=(r+s)-t$，所以可以得到$\dim(W_1+W_2)=\dim W_1+\dim W_2-\dim(W_1\cap W_2)$.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于近期高等代数课程正在讲向量空间，所以想着结合一下高中对于向量空间的学习整理一下一些知识点和笔记。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考书籍：《高等代数（第五版）》（北京大学数学系前代数小组 编，高等教育出版社）（以下简称北大版），《高等代数（第五版）》（张禾瑞、郝鈵新 编</summary>
      
    
    
    
    
    <category term="高等代数笔记" scheme="https://triodelzx.github.io/tags/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>连分数（Continued Fractions）笔记</title>
    <link href="https://triodelzx.github.io/2024/03/09/%E8%BF%9E%E5%88%86%E6%95%B0%EF%BC%88Continued-Fractions%EF%BC%89%E7%AC%94%E8%AE%B0/"/>
    <id>https://triodelzx.github.io/2024/03/09/%E8%BF%9E%E5%88%86%E6%95%B0%EF%BC%88Continued-Fractions%EF%BC%89%E7%AC%94%E8%AE%B0/</id>
    <published>2024-03-09T04:23:07.000Z</published>
    <updated>2024-03-19T06:19:57.538Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>本篇部分整理自《初等数论（第四版）》（闵嗣鹤，严士健编）</em></p></blockquote><h2 id="连分数的定义"><a href="#连分数的定义" class="headerlink" title="连分数的定义"></a>连分数的定义</h2><p>形如：</p><script type="math/tex; mode=display">a_1+\frac{1}{a_2+\frac{1}{\begin{matrix}a_3+\\&&\ddots\\&&&&+\frac{1}{a_n}\end{matrix}}}\tag{1}</script><p>的分数被称作连分数。</p><p>在平常的使用中，为了节省篇幅，我们一般使用以下符号来表示上述连分数：</p><script type="math/tex; mode=display">a_1+\frac{1}{a_2+}\frac{1}{a_3+}\frac{1}{a_4+}\cdots\frac{1}{a_n}或[a_1,a_2,\cdots ,a_n]</script><p>其中第二种表示方式最常用。</p><h2 id="有关连分数的一些定理-amp-定义"><a href="#有关连分数的一些定理-amp-定义" class="headerlink" title="有关连分数的一些定理&amp;定义"></a>有关连分数的一些定理&amp;定义</h2><h3 id="定义1（连分数的渐进分数）："><a href="#定义1（连分数的渐进分数）：" class="headerlink" title="定义1（连分数的渐进分数）："></a>定义1（连分数的渐进分数）：</h3><p>$[a_1,a_2,\cdots ,a_k]=\frac{p_k}{q_k}\ (1\le k\le n)$叫做连分数$(1)$的第$k$个<strong>渐进分数</strong></p><h3 id="定义2（简单连分数）："><a href="#定义2（简单连分数）：" class="headerlink" title="定义2（简单连分数）："></a>定义2（简单连分数）：</h3><p>若$a_1$是整数，$a_2,a_3,\cdots,a_k,\cdots$是正整数，则连分数</p><script type="math/tex; mode=display">[a_1,a_2,\cdots,a_k,\cdots]</script><p>称为<strong>简单连分数</strong>，若$a$的个数有限，则称为<strong>有限简单连分数</strong>，若$a$的个数无限，则称为<strong>无限简单连分数</strong>.</p><p>对于无限连分数，若当$k→∞$时$[a_1,a_2,\cdots,a_n,\cdots]$的渐进分数$\frac{p_k}{q_k}$存在极限，则称这个极限为<strong>连分数$[a_1,a_2,\cdots,a_n,\cdots]$的值.</strong></p><h3 id="定义3（循环连分数）："><a href="#定义3（循环连分数）：" class="headerlink" title="定义3（循环连分数）："></a>定义3（循环连分数）：</h3><p>对于一个无限连分数$[a_1,a_2,\cdots,a_n,\cdots]$，如果能找到两个整数$s\ge0,t&gt;0$使得</p><script type="math/tex; mode=display">a_{s+i}=a_{s+kt+i},\ \ \ i=1,2,\cdots,t;\ \ \ \ k=0,1,2,\cdots</script><p>这个无限简单连分数就叫<strong>循环连分数</strong>，并简单地把它记作</p><script type="math/tex; mode=display">[a_1,a_2, \cdots ,a_s,a_{s+1},\cdots ,a_{s+t}]</script><h3 id="定理1："><a href="#定理1：" class="headerlink" title="定理1："></a>定理1：</h3><p>若连分数$[a_1,a_2,\cdots ,a_n]$的渐进分数是$\frac{p_1}{q_1},\frac{p_2}{q_2},\cdots ,\frac{p_n}{q_n}$，则在这些渐进分数之间，下列关系成立：</p><script type="math/tex; mode=display">\begin{matrix}p_1=a_1,p_2=a_2a_1+1&p_k=a_kp_{k-1}+p_{k-2},\\ q_1=1,q_2=a_2\ \ \ \ \ \ \ \ \ \ \ \ \ &q_k=a_kq_{k-1}+q_{k-2},\end{matrix}\cdots,\ \ \ 3\le k\le n</script><h3 id="定理2："><a href="#定理2：" class="headerlink" title="定理2："></a>定理2：</h3><p>若连分数$[a_1,a_2,\cdots ,a_n]$的$n$个渐进连分数是$\frac{p_k}{q_k},k=1,2,\cdots,n$，则下列两关系成立：</p><script type="math/tex; mode=display">\begin{flalign}&(1)\ \ p_kq_{k-1}-p_{k-1}q_k=(-1)^k,\ \ \ \ \ \ \ \ \ \ k\ge 2\\ &(2)\ \ p_kq_{k-2}-p_{k-2}q_k=(-1)^{k-1}a_k,\ \ k\ge3\end{flalign}</script><h3 id="定理3："><a href="#定理3：" class="headerlink" title="定理3："></a>定理3：</h3><p>设$[a_1,a_2,\cdots,a_n,\cdots]$是简单连分数，$\frac{p_k}{q_k}(k=1,2,\cdots)$是它的渐进分数，则：</p><script type="math/tex; mode=display">\begin{flalign}&(1)\ \ 当k\ge 3时，q_k\ge q_{k-1}+1，因而对任何k来说,q_k\ge k-1\\ &(2)\ \ \frac{p_{2(k-1)}}{q_{2(k-1)}}>\frac{p_{2k}}{q_{2k}},\frac{p_{2k-1}}{q_{2k-1}}>\frac{p_{2k-3}}{q_{2k-3}},\frac{p_{2k}}{q_{2k}}>\frac{p_{2k-1}}{q_{2k-1}}\\ &(3)\frac{p_k}{q_k}(k=1,2,\cdots)都是既约分数\end{flalign}</script><h3 id="定理4："><a href="#定理4：" class="headerlink" title="定理4："></a>定理4：</h3><p>每一简单连分数表示一个实数.</p><h3 id="定理5："><a href="#定理5：" class="headerlink" title="定理5："></a>定理5：</h3><p>任一实无理数可以表成无限简单连分数.</p><h4 id="定理5的推论："><a href="#定理5的推论：" class="headerlink" title="定理5的推论："></a>定理5的推论：</h4><p>对于实无理数$\alpha$，有</p><script type="math/tex; mode=display">\alpha=\frac{p_k}{q_k}+\frac{(-1)^{k-1}\delta_k}{q_kq_{k+1}}或\alpha=\frac{p_k}{q_k}+\frac{(-1)^{k-1}\delta'_k}{q_k^2},其中0<\delta_k<1,0<\delta'_k<1</script><h3 id="定理6："><a href="#定理6：" class="headerlink" title="定理6："></a>定理6：</h3><p>每一实无理数只有一种唯一的方法表成无限简单连分数.</p><h3 id="定理7："><a href="#定理7：" class="headerlink" title="定理7："></a>定理7：</h3><script type="math/tex; mode=display">\begin{flalign}&(1)若\frac{a}{b}=[a_1,a_2,\cdots,a_n]=[b_1,b_2,\cdots,b_n],且a_n>1,b_m>1，则m=n,a_i=b_i\ \ (i=1,2,\cdots,n)\\ &(2)任一有理数\frac{a}{b}有且仅有两种方法表成简单连分数，即\frac{a}{b}=[a_1,a_2,\cdots,a_n]=[a_1,a_2,\cdots,a_n-1,1]\end{flalign}</script><h3 id="定理8："><a href="#定理8：" class="headerlink" title="定理8："></a>定理8：</h3><p>若$\alpha$是任一实数，$\frac{p_k}{q_k}$是$\alpha$的第$k$个渐进分数，则在分母小于等于$q_k$的一切有理数中，$\frac{p_k}{q_k}$是$\alpha$最好的有理近似值，即若$0&lt;q\le q_k$，则</p><script type="math/tex; mode=display">|{\alpha-\frac{p_k}{q_k}}|\le|{\alpha-\frac{p}{q}}|</script><h3 id="定理9："><a href="#定理9：" class="headerlink" title="定理9："></a>定理9：</h3><p>每一循环连分数一定是某一整系数二次不可约方程的实根.</p><h3 id="定理10："><a href="#定理10：" class="headerlink" title="定理10："></a>定理10：</h3><p>若$f(x)=ax^2+bx+c$是一个整系数二次不可约多项式，$\alpha$是$f(x)=0$的一个实根，则表示$\alpha$的简单连分数是一循环连分数.</p><h3 id="定理11（Legendre定理）："><a href="#定理11（Legendre定理）：" class="headerlink" title="定理11（Legendre定理）："></a>定理11（Legendre定理）：</h3><p>对于有理数$\alpha$，若整数$c,d$满足</p><script type="math/tex; mode=display">|{\alpha-\frac{c}{d}}|<\frac{1}{2d^2}</script><p>那么$\frac{c}{d}$就是$\alpha$的一个有理近似.</p><h2 id="连分数的应用实例"><a href="#连分数的应用实例" class="headerlink" title="连分数的应用实例"></a>连分数的应用实例</h2><h3 id="佩尔方程-Pell-equation"><a href="#佩尔方程-Pell-equation" class="headerlink" title="佩尔方程(Pell equation)"></a>佩尔方程(Pell equation)</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>形如$x^2-dy^2=1$的不定方程被称为<strong>佩尔方程</strong></p><p>现求佩尔方程有正整数解的条件：</p><p>在实数域对方程$x^2-dy^2=1$进行分解有$(x+\sqrt{d}y)(x-\sqrt{d}y)=1$</p><p>(1)当$d$为完全平方数</p><p>则有$x+\sqrt{d}y,x-\sqrt{d}y$均为整数，那么若$(x+\sqrt{d}y)(x-\sqrt{d}y)=1$，则必有$x+\sqrt{d}y=x-\sqrt{d}y=1$</p><p>而满足这种情况的非负整数对$(x,y)=(1,0)$所以方程$x^2-dy^2=1$并不存在正整数解.</p><p>(2)当$d$为非完全平方数</p><h3 id="定理12："><a href="#定理12：" class="headerlink" title="定理12："></a>定理12：</h3><p>对任何正整数$n$，都存在两个整数$P_n,Q_n$，使得</p><script type="math/tex; mode=display">\alpha_n=\frac{\sqrt{d}+P_n}{Q_n},且P_n^2\equiv d\ (mod\ Q_n)</script><p>成立.</p><h3 id="定理13："><a href="#定理13：" class="headerlink" title="定理13："></a>定理13：</h3><p>若$d$是一个非平方的正整数，$Q_n$为<strong>定理12</strong>中所定义，则二次不定方程$x^2-dy^2=(-1)^nQ_n$有正整数解$x,y$且$(x,y)=1$.</p><h3 id="定理14："><a href="#定理14：" class="headerlink" title="定理14："></a>定理14：</h3><p>若有$\sqrt{d}=[a_1,a_2, \cdots ,a_s,a_{s+1}, \cdots ,a_{s+t}],n&gt;s$而$Q_n$为<strong>定理12</strong>所定义，则方程$x^2-dy^2=(-1)^nQ_n$有无穷多个正整数解 $|{p_{m+lt}}|,q_n+lt,2\ |\ l,l\ge0$ .（其中 $\frac {p_{m+lt}}{q_{m+lt}}$ 为 $\sqrt {d}$ 的第 $m+lt$ 个渐进分数）.</p><p>由<strong>定理14</strong>可知存在一正整数$Q$（取$Q=(-1)^nQ_n,n&gt;s$）使得不定方程$x^2-dy^2=Q$有无穷多组正整数解，则在这些解中必存在两组不同的正整数$x_1y_1;x_2y_2$使得</p><script type="math/tex; mode=display">x_1\equiv x_2\ (mod\ |{Q}|)\ ,\ y_1\equiv y_2\ (mod\ |{Q}|)</script><p>成立.由于$x^2_1-dy^2_1=x^2_2-dy^2_2=Q$，故有</p><script type="math/tex; mode=display">Q^2=(x_1^2-dy_1^2)(x_2^2-dy_2^2)=(x_1x_2-dy_1y_2)^2-d(x_1y_2-x_2y_1)^2</script><p>由$x_1\equiv x_2\ (mod\ |{Q}|)\ ,\ y_1\equiv y_2\ (mod\ |{Q}|)$可得：</p><script type="math/tex; mode=display">x_1x_2-dy_1y_2\equiv x_1^2-dy_1^2\equiv 0\ (mod\ |{Q}|),\\ x_1y_2-x_2y_1\equiv x_1y_1-x_1y_1\equiv 0\ (mod\ |{Q}|)</script><p>故若令$|{\frac{x_1x_2-dy_1y_2}{Q}}|=x,|{\frac{x_1y_2-x_2y_1}{Q}}|=y$，可知$x,y$均为非负整数且为方程$x^2-dy^2=1$的一解.</p><p>显然有$x\neq0$，否则有$-dy^{2}=1$，与$d&gt;0$矛盾；且有$y\neq0$否则有$x_1y_2-x_2y_1=0$，由引理2知$(x_1,y_1)=(x_2,y_2)=1$，所以有$x_1\ |\ x_2,x_2\ |\ x_1$，由于$x_1,x_2$均为正整数，所以有$x_1=x_2,y_1=y_2$，与$x_1,y_1;x_2;y_n$不同的定义相悖.故可知$x,y$为方程$x^2-dy^2=1$的一组正整数解.</p><p>综上所述，当$d$为完全平方数时，不定方程$x^2-dy^2=1$有正整数解.</p><h4 id="现在求不定方程-x-2-dy-2-1-的正整数解："><a href="#现在求不定方程-x-2-dy-2-1-的正整数解：" class="headerlink" title="现在求不定方程$x^2-dy^2=1$的正整数解："></a>现在求不定方程$x^2-dy^2=1$的正整数解：</h4><h3 id="定理15："><a href="#定理15：" class="headerlink" title="定理15："></a>定理15：</h3><p>若$x_0,y_0$是方程$x^2-dy^2=1$的一组正整数解，且$x_0+\sqrt{d}y_0$是形如$x+\sqrt{d}y$（$x,y$是方程$x^2-dy^2=1$的正整数解）的最小数，则方程$x^2-dy^2=1$的一切正整数解$x,y$可以由</p><script type="math/tex; mode=display">x\pm\sqrt{d}y=\big(x_0+\sqrt{d}y_0\big)^n,n=1,2,\cdots</script><p>确定.</p><p>有了<strong>定理15</strong>，我们可以通过一个佩尔方程的最小正整数解求出这个佩尔方程的所有解.现在我们的目标就成为找到如何求佩尔方程的最小正整数解.</p><p> 实际上，对于不为完全平方数的$\sqrt{d}=[a_1,a_2,\cdots,a_n,\cdots]$我们总能找到$a_{n+1}$满足$a_i=2a_1(i=2,3,\cdots,n)$，则$\frac{x}{y}=[a_1,a_2,\cdots,a_{n}]$可能为$d$定义的佩尔方程的一组解.</p><p>求佩尔方程最小整数解的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span>*</span><br><span class="line">d = ...</span><br><span class="line">cf = continued_fraction(sqrt(d))</span><br><span class="line">a0 = cf[<span class="number">0</span>]</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> cf[i] == <span class="number">2</span>*a0:</span><br><span class="line">        c = cf.convergent(i-<span class="number">1</span>)</span><br><span class="line">        x, y = c.as_integer_ratio()</span><br><span class="line">        <span class="keyword">if</span> x**<span class="number">2</span> - d*y**<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>((x,y))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在这里扩展地提一下广义佩尔方程：</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>形如$x^2-dy^2=c$的方程称为广义佩尔方程.</p><h4 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h4><p>通过连分数求出广义佩尔方程的最小正整数解$(x_0,y_0)$后，可以知道$(x_0r+Dy_0s,x_0s+y_0r)$也是该方程的整数解（其中$r,s$为方程$r^2-ds^2=1$的整数解）</p><h4 id="求解代码"><a href="#求解代码" class="headerlink" title="求解代码"></a>求解代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pell_roots</span>(<span class="params">D: <span class="built_in">int</span>, C: <span class="built_in">int</span> = <span class="number">1</span></span>):</span><br><span class="line">    intervals = <span class="number">2</span>**<span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_a_root</span>(<span class="params">D: <span class="built_in">int</span>, C: <span class="built_in">int</span></span>):</span><br><span class="line">        cf = continued_fraction(sqrt(D))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, intervals):</span><br><span class="line">            c = cf.convergent(i - <span class="number">1</span>)</span><br><span class="line">            x, y = c.as_integer_ratio()</span><br><span class="line">            <span class="keyword">if</span> x**<span class="number">2</span> - D * y**<span class="number">2</span> == C:</span><br><span class="line">                <span class="keyword">return</span> x, y</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, intervals):</span><br><span class="line">            x2 = C + D * y**<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> x2 &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            x = isqrt(x2)</span><br><span class="line">            <span class="keyword">if</span> x ** <span class="number">2</span> == x2:</span><br><span class="line">                <span class="keyword">return</span> x, y</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span> </span><br><span class="line">    r, s = get_a_root(D, <span class="number">1</span>)</span><br><span class="line">    x, y = get_a_root(D, C)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> x, y</span><br><span class="line">        x, y = x * r + D * y * s, r * y + s * x</span><br><span class="line">D = ...</span><br><span class="line">C = ...</span><br><span class="line">x, y = <span class="built_in">next</span>(pell_roots(D, C))</span><br><span class="line"><span class="built_in">print</span>(x**<span class="number">2</span> - D * y**<span class="number">2</span> == C)</span><br><span class="line"><span class="built_in">print</span>((x,y))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="RSA的维纳攻击"><a href="#RSA的维纳攻击" class="headerlink" title="RSA的维纳攻击"></a>RSA的维纳攻击</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>考虑一般的RSA，$c\equiv m^e\ (mod\ n),n=pq$，$p,q$均为质数，在这里$e$非常大，这也是适用维纳攻击的RSA的明显特征，有$\varphi(n)=(p-1)(q-1)$，则有</p><script type="math/tex; mode=display">\varphi(n)=(p-1)(q-1)=pq-p-q+1=N-p-\frac{n}{p}+1</script><p>故有$p^2+p\big[\varphi(n)-n-1\big]+n=0$</p><p>故若我们已知$n$和$\varphi(n)$，我们就可以对$n$进行分解.</p><p>又由于在RSA中，有$ed\equiv1\ (mod\ \varphi(n))$，所以存在整数$k$使得$ed=k\varphi(n)+1$</p><p>即有</p><script type="math/tex; mode=display">|{\frac{e}{\varphi(n)}-\frac{k}{d}}|=\frac{1}{d\varphi(n)}</script><p>由<strong>定理11（Legendre定理）</strong>可知：$\frac{k}{d}$是$\frac{e}{\varphi(n)}$的一个有理近似，故我们可以通过$\frac{e}{\varphi(n)}$的有理近似获得$\frac{k}{d}$，当$n=pq$且$q&lt;p&lt;2q$时，若满足$d&lt;\frac{1}{3}n^\frac{1}{4}$，则$\frac{k}{d}$为$\frac{e}{n}$的一个有理近似.</p><h4 id="求解步骤"><a href="#求解步骤" class="headerlink" title="求解步骤"></a>求解步骤</h4><p>(1)估测是否满足$d&lt;\frac{1}{3}n^\frac{1}{4}$</p><p>(2)求$\frac{e}{n}$的连分数展开</p><p>(3)迭代连分数$\frac{k_i}{d_i}$：先使用$k_i,d_i$求出$\varphi_i(n)$，再通过$\varphi_i(n)$计算出$n$，验证$\varphi_i(n)$是否正确</p><h4 id="解密脚本："><a href="#解密脚本：" class="headerlink" title="解密脚本："></a>解密脚本：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wienerAttack</span>(<span class="params">n, e</span>):</span><br><span class="line">    cf = continued_fraction(e / n)</span><br><span class="line">    convers = cf.convergents()</span><br><span class="line">    <span class="keyword">for</span> pkd <span class="keyword">in</span> convers:</span><br><span class="line">        pk, pd = pkd.as_integer_ratio()</span><br><span class="line">        <span class="keyword">if</span> pk == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> (e * pd - <span class="number">1</span>) % pk != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        pphi = (e * pd - <span class="number">1</span>) // pk</span><br><span class="line">        p = var(<span class="string">&#x27;p&#x27;</span>, domain=ZZ)</span><br><span class="line">        roots = solve(p ** <span class="number">2</span> + (pphi - n - <span class="number">1</span>) * p + n, p)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(roots) == <span class="number">2</span>:</span><br><span class="line">            pp, pq = roots</span><br><span class="line">            <span class="keyword">if</span> pp * pq == n:</span><br><span class="line">                <span class="keyword">return</span> pp, pq, pd</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">n = ...</span><br><span class="line">e = ...</span><br><span class="line">c = ...</span><br><span class="line">p, q, d = wienerAttack(n, e)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;本篇部分整理自《初等数论（第四版）》（闵嗣鹤，严士健编）&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;连分数的定义&quot;&gt;&lt;a href=&quot;#连分数的定义&quot; class=&quot;headerlink&quot; title=&quot;连分数的定义&quot;&gt;</summary>
      
    
    
    
    <category term="数论笔记" scheme="https://triodelzx.github.io/categories/%E6%95%B0%E8%AE%BA%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Crypto" scheme="https://triodelzx.github.io/tags/Crypto/"/>
    
    <category term="数学" scheme="https://triodelzx.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>LCG笔记</title>
    <link href="https://triodelzx.github.io/2023/12/17/LCG%E7%AC%94%E8%AE%B0/"/>
    <id>https://triodelzx.github.io/2023/12/17/LCG%E7%AC%94%E8%AE%B0/</id>
    <published>2023-12-17T14:13:59.000Z</published>
    <updated>2023-12-17T14:44:56.723Z</updated>
    
    <content type="html"><![CDATA[<p>LCG，全称线性同余方发生器（Linear congruential generator），是一种伪随机序列生成器算法，生成器由下式定义：</p><script type="math/tex; mode=display">X_{n+1}\equiv aX_n+b\ (mod\ p)</script><p>在CTF中，一般有以下题型：</p><h2 id="一-求逆"><a href="#一-求逆" class="headerlink" title="一.求逆"></a>一.求逆</h2><p>所谓求逆，其实即为已知a,b,p,c后求解方程：</p><script type="math/tex; mode=display">c\equiv(ax+b)\ (mod\ p)</script><p>由数论知识我们很容易可以知道：</p><script type="math/tex; mode=display">x\equiv(c-b)a^{-1}\ (mod\ p)</script><p>对于这类题目，我们只需利用以上公式即可快速解出。</p><h2 id="二-求参数a-b后求逆"><a href="#二-求参数a-b后求逆" class="headerlink" title="二.求参数a,b后求逆"></a>二.求参数a,b后求逆</h2><p>这类题型一般都会给出一列连续经过几次线性同余的数据后得出的数据和p，我们需要通过这些有限的数据来求解原来的数据，在此之前我们需要先求解a和b，大致过程如下：</p><p>假设已知<script type="math/tex">x_{n},x_{n+1},x_{n+2}</script>，我们有：</p><script type="math/tex; mode=display">x_{n+1}\equiv ax_n+b\ (mod\ p)\\ x_{n+2}\equiv ax_{n+1}+b\ (mod\ p)</script><p>所以我们有：</p><script type="math/tex; mode=display">x_{n+2}-x_{n+1}\equiv a(x_{n+1}-x_n)\ (mod\ p)</script><p>所以：</p><script type="math/tex; mode=display">a\equiv (x_{n+2}-x_{n+1})(x_{n+1}-x_n)^{-1}\ (mod\ p)(假定(x_{n+1}-x_n)与p互质)</script><p>那么我们有：</p><script type="math/tex; mode=display">b\equiv x_{n+1}-ax_n\ (mod\ p)</script><p>这样我们就可以得到a,b，再通过求逆得出原来的数据即可。</p><h3 id="例：-Newstar-CTF2023-Week3-babyrandom"><a href="#例：-Newstar-CTF2023-Week3-babyrandom" class="headerlink" title="例：[Newstar  CTF2023]Week3    babyrandom"></a>例：[Newstar  CTF2023]Week3    babyrandom</h3><p>加密代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"></span><br><span class="line">p = <span class="number">64999433139797068147576269731948390094958654326970231465808792590598519729077</span></span><br><span class="line"></span><br><span class="line">a = randrange(<span class="number">2</span>, p)</span><br><span class="line">b = randrange(<span class="number">2</span>, p)</span><br><span class="line">x = bytes_to_long(flag)</span><br><span class="line">menu = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Random as a Service with LCG backend</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Enter your option</span></span><br><span class="line"><span class="string">1. Reset</span></span><br><span class="line"><span class="string">2. Get</span></span><br><span class="line"><span class="string">3. Exit</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GetRandom</span>():</span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    nx = (a*x + b) % p</span><br><span class="line">    <span class="built_in">print</span>(nx)</span><br><span class="line">    x = nx</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(menu)</span><br><span class="line">    opt = <span class="built_in">input</span>(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        opt = <span class="built_in">int</span>(opt)</span><br><span class="line">        <span class="keyword">if</span> opt == <span class="number">1</span>:</span><br><span class="line">            x = bytes_to_long(flag)</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="number">2</span>:</span><br><span class="line">            GetRandom()</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;invalid option&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;oh no, something wrong!&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>这道题提供了靶机，可以通过靶机得出三个连续加密后数据，解密代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pwn</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">x = []</span><br><span class="line">p = <span class="number">64999433139797068147576269731948390094958654326970231465808792590598519729077</span></span><br><span class="line">io = pwn.remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25624</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recv()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    data = io.recvline()</span><br><span class="line">    io.recv()</span><br><span class="line">    x.append(<span class="built_in">int</span>(data))</span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">a = (x[<span class="number">2</span>]-x[<span class="number">1</span>])*gmpy2.invert(x[<span class="number">1</span>]-x[<span class="number">0</span>],p)%p</span><br><span class="line">b = (x[<span class="number">1</span>]-a*x[<span class="number">0</span>])%p</span><br><span class="line">x = (x[<span class="number">0</span>]-b)*gmpy2.invert(a,p)%p</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(x))</span><br></pre></td></tr></table></figure><p>运行可得flag：</p><blockquote><p>flag{lcg_1s_n0t_s3cur3#fb528ba5}</p></blockquote><h2 id="三-求参数a-b-p后求逆"><a href="#三-求参数a-b-p后求逆" class="headerlink" title="三.求参数a,b,p后求逆"></a>三.求参数a,b,p后求逆</h2><p>与上一种形式相似，但是多了个p要求，我们假设一个数列：</p><script type="math/tex; mode=display">\{x_0,x_1,x_2,\cdots,x_{n-1},x_{n},\cdots\}</script><p>其满足：</p><script type="math/tex; mode=display">x_{n+1}\equiv ax_n+b\ (mod\ p)</script><p>假设有一个数列 <script type="math/tex">\{t_n\}</script> 有：</p><script type="math/tex; mode=display">t_n\equiv x_{n+1}-x_n\equiv a(x_n-x_{n-1})\equiv at_{n-1}\ (mod\ p)</script><p>所以：</p><script type="math/tex; mode=display">t_{n+1}t_{n-1}\equiv a^{2}t_{n-1}^2\equiv t_n^2\ (mod\ p)</script><p>也就是说：</p><script type="math/tex; mode=display">t_{n+1}t_{n-1}-t_n^{2}=kp\ (k\in Z)</script><p>同理，有：</p><script type="math/tex; mode=display">t_{n+2}t_{n}-t_{n+1}^{2}=k'p\ (k'\in Z)</script><p>所以：</p><script type="math/tex; mode=display">p=gcd(t_{n+2}t_{n}-t_{n+1}^{2},t_{n+1}t_{n-1}-t_n^{2})</script><p>求出p后我们就可以由上种类型继续求解。</p><p>但是要注意，上面求出的p不一定就是实际要求的p，所以需要综合多组数据求解。</p><h3 id="例：-PCTF2023-cgl"><a href="#例：-PCTF2023-cgl" class="headerlink" title="例：[PCTF2023]cgl"></a>例：[PCTF2023]cgl</h3><p>加密代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secrets <span class="keyword">import</span> flag,hint,key_number</span><br><span class="line"></span><br><span class="line">hint=bytes_to_long(hint)</span><br><span class="line"></span><br><span class="line">a = getPrime(<span class="number">256</span>)</span><br><span class="line">b = getPrime(<span class="number">256</span>)</span><br><span class="line">n = getPrime(<span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">state = hint</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    state = (state * a + b) % n</span><br><span class="line">    result.append(state)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enc=<span class="built_in">list</span>(base64.b64encode(flag))</span><br><span class="line">seed(key_number)</span><br><span class="line">shuffle(enc)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>(enc))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[64808739969023370119048821688797617211776674130654821075486774236651303382814, </span></span><br><span class="line"><span class="string">79259085906502785899793009961165414442137337544515472474317826031734962148580, </span></span><br><span class="line"><span class="string">47572752582229256276978761367590954300620113464013293239765792280017260371290, </span></span><br><span class="line"><span class="string">38491979589561565391093783861378040494484383004914878495301417593240442882761, </span></span><br><span class="line"><span class="string">58955289126482266943455593731576872529828229203595014577711629479455475819111]</span></span><br><span class="line"><span class="string">b&#x27;QkiTMMx3St9IYTLMN2DmR0t53zd1MhmJT1hZ2YiwMZETVhwhOGYVZYcD&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题很明显要通过上述方法来求解hint，在这里我们只求解hint，求解代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">x = [<span class="number">64808739969023370119048821688797617211776674130654821075486774236651303382814</span>, </span><br><span class="line"><span class="number">79259085906502785899793009961165414442137337544515472474317826031734962148580</span>, </span><br><span class="line"><span class="number">47572752582229256276978761367590954300620113464013293239765792280017260371290</span>, </span><br><span class="line"><span class="number">38491979589561565391093783861378040494484383004914878495301417593240442882761</span>, </span><br><span class="line"><span class="number">58955289126482266943455593731576872529828229203595014577711629479455475819111</span>]</span><br><span class="line">t = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    t.append(x[i+<span class="number">1</span>]-x[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">2</span>):</span><br><span class="line">    p = gmpy2.gcd(t[i+<span class="number">2</span>]*t[i]-t[i+<span class="number">1</span>]*t[i+<span class="number">1</span>],t[i+<span class="number">1</span>]*t[i-<span class="number">1</span>]-t[i]*t[i])</span><br><span class="line">    a = (x[<span class="number">2</span>]-x[<span class="number">1</span>])*gmpy2.invert(x[<span class="number">1</span>]-x[<span class="number">0</span>],p)%p</span><br><span class="line">    b = (x[<span class="number">1</span>]-a*x[<span class="number">0</span>])%p</span><br><span class="line">    x = (x[<span class="number">0</span>] - b) * gmpy2.invert(a, p) % p</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(x))</span><br></pre></td></tr></table></figure><p>运行可以得出hint：</p><blockquote><p>key_number=randrange(999999)</p></blockquote><p>要注意的是：在这种情况下，<script type="math/tex">\{x_n\}</script>的元素数量应该至少要有5个才能求解出p。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;LCG，全称线性同余方发生器（Linear congruential generator），是一种伪随机序列生成器算法，生成器由下式定义：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
X_{n+1}&#92;equiv aX_n+b&#92; (m</summary>
      
    
    
    
    <category term="密码学笔记" scheme="https://triodelzx.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Crypto" scheme="https://triodelzx.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>Anshel–Anshel–Goldfeld 密钥交换体系(Anshel–Anshel–Goldfeld key exchange)</title>
    <link href="https://triodelzx.github.io/2023/12/15/Anshel%E2%80%93Anshel%E2%80%93Goldfeld-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E4%BD%93%E7%B3%BB-Anshel%E2%80%93Anshel%E2%80%93Goldfeld-key-exchange/"/>
    <id>https://triodelzx.github.io/2023/12/15/Anshel%E2%80%93Anshel%E2%80%93Goldfeld-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E4%BD%93%E7%B3%BB-Anshel%E2%80%93Anshel%E2%80%93Goldfeld-key-exchange/</id>
    <published>2023-12-15T12:50:27.000Z</published>
    <updated>2023-12-17T07:39:25.567Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原理（代数密钥建立协议，The-algebraic-key-establishment-protocol）"><a href="#原理（代数密钥建立协议，The-algebraic-key-establishment-protocol）" class="headerlink" title="原理（代数密钥建立协议，The algebraic key establishment protocol）"></a>原理（代数密钥建立协议，The algebraic key establishment protocol）</h3><p>​    We now present an algebraic key establishment protocol which, in its most general form consists of a five–tuple </p><script type="math/tex; mode=display">(U, V,\beta,\gamma_1, \gamma_2)</script><p>where <script type="math/tex">U</script> and <script type="math/tex">V</script> are feasibly computable monoids, and</p><script type="math/tex; mode=display">\beta:U× U\rightarrow V,\ \ \ \gamma_i:U× V\rightarrow V\ \ (i=1,2)</script><p>are feasibly computable functions satisfying the following properties.</p><p>​    (i) For all elements <script type="math/tex">x, y_1, y_2 \in U</script> ,</p><script type="math/tex; mode=display">\beta(x,y_1\cdot y_2)=\beta(x,y_1)\cdot \beta(x,y_2)</script><p>​    (ii) For all elements <script type="math/tex">x, y \in U</script> ,</p><script type="math/tex; mode=display">\gamma_1(x,\beta(y,x))=\gamma_2(x,\beta(x,y))</script><p>​    (iii) Suppose <script type="math/tex">y_1, y_2, \cdots ,y_k \in U</script> and <script type="math/tex">\beta(x, y_1), \beta(x, y_2), \cdots ,\beta(x, y_k)</script> are publicly known for some secret element <script type="math/tex">x \in U</script>. Then, in general, it is infeasible to determine the secret element <script type="math/tex">x</script> .</p><p>​    The users <script type="math/tex">A</script> and <script type="math/tex">B</script> are publicly assigned submonoids, <script type="math/tex">S_A, T_B \subseteq U</script>, respectively. Suppose that <script type="math/tex">S_A</script> is generated by the elements</p><script type="math/tex; mode=display">\{s_1,\cdots ,s_m\}</script><p>and <script type="math/tex">S_B</script> is generated by <script type="math/tex">\{t_1,\cdots,t_n\}</script>.The protocol begins with user A choosing a secret element a in <script type="math/tex">S_A</script> and transmitting the elements</p><script type="math/tex; mode=display">\beta(a,t_i)\ \ \ \ \ \ i=1,\cdots,n.</script><p>Likewise, user <script type="math/tex">B</script> chooses a secret element <script type="math/tex">b</script> in <script type="math/tex">T</script>, transmits</p><script type="math/tex; mode=display">\beta(b,s_i)\ \ \ \ \ \ i=1,\cdots,m.</script><p>It follows from property (iii) that even though the transmission is over a public channel, the secret elements <script type="math/tex">a</script> and <script type="math/tex">b</script> are secure. Property (i) above insures that user <script type="math/tex">A</script> can compute the element</p><script type="math/tex; mode=display">\beta(b,a),</script><p>and</p><script type="math/tex; mode=display">\gamma_1(a,\beta(b,a)).</script><p>Likewise user <script type="math/tex">B</script> can compute <script type="math/tex">\beta(a, b)</script> and <script type="math/tex">\gamma_2(b, \beta(a, b))</script>. Recalling property (ii) above we see that</p><script type="math/tex; mode=display">\kappa=\gamma_1(a,\beta(b,a))=\gamma_2(b,\beta(a,b))</script><p>can serve as an established key.</p><h3 id="具体例子（群论协议，A-group-theoretic-protocol）"><a href="#具体例子（群论协议，A-group-theoretic-protocol）" class="headerlink" title="具体例子（群论协议，A group theoretic protocol）"></a>具体例子（群论协议，A group theoretic protocol）</h3><p>In this illustration the monoid <script type="math/tex">U = V</script> is a group, denoted <script type="math/tex">G</script>, and the users <script type="math/tex">A</script> and <script type="math/tex">B</script> are publicly assigned subgroups</p><script type="math/tex; mode=display">S_A=\langle s_1,s_2,\cdots ,s_m\rangle,\ \ \ \ S_B=\langle t_1,t_2,\cdots ,t_n\rangle.</script><p>Here the function <script type="math/tex">\beta:G× G\rightarrow G</script> is chosen to be conjugation,</p><script type="math/tex; mode=display">\gamma_1(u,v)=u^{-1}v,\ \ \ \ \ \ \gamma_2(u,v)=v^{-1}u.</script><p>Users A and B choose secret elements <script type="math/tex">a \in S_A</script> and <script type="math/tex">b \in S_B</script> respectively, and user <script type="math/tex">A</script> begins the protocol by computing, rewriting, and transmitting the collection of elements</p><script type="math/tex; mode=display">a^{-1}t_1a,a^{-1}t_2a,\cdots ,a^{-1}t_na.</script><p>Similarly, user <script type="math/tex">B</script> computes, rewrites, and transmits</p><script type="math/tex; mode=display">b^{-1}s_1b,b^{-1}s_2b,\cdots,b^{-1}s_mb.</script><p>An adversary observing these transmissions is unable to determine <script type="math/tex">a</script> or <script type="math/tex">b</script> unless <script type="math/tex">(s)</script> he can solve a set of simultaneous conjugacy equations over the base group. </p><p>​    Multiplying two elements in the group can be accomplished by simply concatenating the two expressions representing the elements. The process of rewriting, while not unique, must be chosen so that no adversary can determine the conjugating element from viewing the publicly transmitted conjugates.</p><p>​    Recalling that the conjugate of the product of two elements is the product of the conjugates of those elements (i.e., property (i) of <script type="math/tex">\beta</script>), users <script type="math/tex">A</script> and <script type="math/tex">B</script> are now in a position to compute, respectively, the elements</p><script type="math/tex; mode=display">\beta(b,a)=b^{-1}ab,\ \ \ \ \ \ \ \ \beta(a,b)=a^{-1}ba.</script><p>In order to attain a common key, user <script type="math/tex">A</script> computes</p><script type="math/tex; mode=display">\kappa=\gamma_1(a,\beta(b,a))=a^{-1}b^{-1}ab=[a,b],</script><p>and user <script type="math/tex">B</script> computes</p><script type="math/tex; mode=display">\kappa=\gamma_2(a,\beta(b,a))=[a,b].</script><p>（上文摘自<em>Mathematical Research Letters 6, 287–291 (1999),AN ALGEBRAIC METHOD FOR PUBLIC-KEY CRYPTOGRAPHY</em>,Iris Anshel, Michael Anshel, and Dorian Goldfeld著）</p><h4 id="应用例"><a href="#应用例" class="headerlink" title="应用例"></a>应用例</h4><h5 id="UTCTF2020-Cube-Crypto"><a href="#UTCTF2020-Cube-Crypto" class="headerlink" title="[UTCTF2020]Cube Crypto"></a>[UTCTF2020]Cube Crypto</h5><p>Mr. Anshel and Mr. Goldfeld were trying to exchange some asymmetric keys to get a shared key. They aren’t very good at math, so they decided to use a Rubik’s Cube instead to do the crypto. I don’t think it’s very secure though, I think you might be able to guess some of their keys :hmm:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mr. A public key: [B&#x27; U&#x27;, F B F, R&#x27; D, B D&#x27;]</span><br><span class="line">Mr. G public key: [R D L&#x27;, D U&#x27; B, U F&#x27;, L&#x27; F]</span><br><span class="line"></span><br><span class="line">Mr. A sends: [B D&#x27; R&#x27; D R D L&#x27; D&#x27; R D B&#x27;, B D&#x27; R&#x27; D D U&#x27; B D&#x27; R D B&#x27;, B D&#x27; R&#x27; D U F&#x27; D&#x27; R D B&#x27;, B D&#x27; R&#x27; D L&#x27; F D&#x27; R D B&#x27;]</span><br><span class="line">Mr. G sends: [U F&#x27; R D L&#x27; B&#x27; U&#x27; L D&#x27; R&#x27; F U&#x27;, U F&#x27; R D L&#x27; F B F L D&#x27; R&#x27; F U&#x27;, U F&#x27; R D L&#x27; R&#x27; D L D&#x27; R&#x27; F U&#x27;, U F&#x27; R D L&#x27; B D&#x27; L D&#x27; R&#x27; F U&#x27;]</span><br></pre></td></tr></table></figure><p><strong>NOTE: The flag is the shared key that they generate, so it is NOT in <code>utflag&#123;&#125;</code> format</strong></p><p>显然的，这道题需要应用Anshel–Anshel–Goldfeld 密钥交换体系，在这里，密钥是由魔方转动记号呈现的，而我们知道，魔方的转动操作群是非阿贝尔群，在这里，我们可以从Mr.A和Mr.G提供的公钥中提取出：</p><script type="math/tex; mode=display">S_A=\langle s_1,s_2,s_3,s_4\rangle\ \ \ \ \ \ \ S_G=\langle t_1,t_2,t_3,t_4\rangle</script><p>其中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s_1=B&#x27; U&#x27;</span><br><span class="line">s_2=F B F</span><br><span class="line">s_3=R&#x27; D</span><br><span class="line">s_4=B D&#x27;</span><br><span class="line">t_1=R D L&#x27;</span><br><span class="line">t_2=D U&#x27; B</span><br><span class="line">t_3=U F&#x27;</span><br><span class="line">t_4=L&#x27; F</span><br></pre></td></tr></table></figure><p>又设在交换后得出的密文的集合分别为：</p><script type="math/tex; mode=display">C_G=\langle s_1',s_2',s_3',s_4'\rangle\ \ \ \ \ \ \ C_A=\langle t_1',t_2',t_3',t_4'\rangle</script><p>其中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s_1&#x27;=U F&#x27; R D L&#x27; B&#x27; U&#x27; L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">s_2&#x27;=U F&#x27; R D L&#x27; F B F L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">s_3&#x27;=U F&#x27; R D L&#x27; R&#x27; D L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">s_4&#x27;=U F&#x27; R D L&#x27; B D&#x27; L D&#x27; R&#x27; F U&#x27;</span><br><span class="line">t_1&#x27;=B D&#x27; R&#x27; D R D L&#x27; D&#x27; R D B&#x27;</span><br><span class="line">t_2&#x27;=B D&#x27; R&#x27; D D U&#x27; B D&#x27; R D B&#x27;</span><br><span class="line">t_3&#x27;=B D&#x27; R&#x27; D U F&#x27; D&#x27; R D B&#x27;</span><br><span class="line">t_4&#x27;=B D&#x27; R&#x27; D L&#x27; F D&#x27; R D B&#x27;</span><br></pre></td></tr></table></figure><p>我们假设共享密钥为<script type="math/tex">a^{-1}g^{-1}ag</script>，所以我们有：</p><script type="math/tex; mode=display">a^{-1}t_ia=t_i'\ \ \ \ \ g^{-1}s_ig=s_i'\ \ \ \ \ (i=1,2,3,4)</script><p>通过观察我们很容易可以得到：</p><script type="math/tex; mode=display">a=D' R D B'\\g=L D' R' F U'</script><p>所以我们可以得出共享密钥：</p><script type="math/tex; mode=display">a^{-1}g^{-1}ag=B D' R' DU F' R D L'D' R D B'L D' R' F U'</script><p>这样我们就得到了flag：</p><blockquote><p>utflag{B D’ R’ D U F’ R D L’ D’ R D B’ L D’ R’ F U’}</p></blockquote><p>至此，对于Anshel–Anshel–Goldfeld 密钥交换体系的介绍就到此结束了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;原理（代数密钥建立协议，The-algebraic-key-establishment-protocol）&quot;&gt;&lt;a href=&quot;#原理（代数密钥建立协议，The-algebraic-key-establishment-protocol）&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="密码学笔记" scheme="https://triodelzx.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Crypto" scheme="https://triodelzx.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>Triode的RSA学习笔记（1）</title>
    <link href="https://triodelzx.github.io/2023/11/17/Triode%E7%9A%84RSA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <id>https://triodelzx.github.io/2023/11/17/Triode%E7%9A%84RSA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</id>
    <published>2023-11-17T05:20:03.000Z</published>
    <updated>2023-11-17T05:23:46.300Z</updated>
    
    <content type="html"><![CDATA[<p>在进行RSA解密之前，我们先要理解RSA的加密原理：</p><p>已知明文<script type="math/tex">a</script>，公钥对<script type="math/tex">(n,e)</script>，加密过程如下:</p><script type="math/tex; mode=display">b\equiv a^e\ (mod\ n)</script><p>若要对已知的密文进行解密，我们就需要得到私钥(Private Key)：</p><p>设对于上述加密过程所得出的私钥为<script type="math/tex">d</script>，则：</p><script type="math/tex; mode=display">a\equiv b^d\ (mod\ n)</script><p>很明显：</p><script type="math/tex; mode=display">b^{ed}\equiv a^e\equiv b\ (mod\ n)</script><p>所以：</p><script type="math/tex; mode=display">b^{ed-1}\equiv 1\ (mod\ n)</script><p>一般情况下，<script type="math/tex">gcd(n,b)=1</script>，故先对这种情况进行考虑</p><p>由欧拉定理：我们知道</p><script type="math/tex; mode=display">b^{\varphi(n)}\equiv 1\ (mod\ n)</script><p>很显然：</p><script type="math/tex; mode=display">ed-1=k\varphi(n)</script><p>可以看出：</p><script type="math/tex; mode=display">ed\equiv1\ (mod\ \varphi(n))</script><p>所以：</p><script type="math/tex; mode=display">d=inv(e,\varphi(n))\ (inv(e,\varphi(n))为e模\varphi(n)的乘法逆元)</script><hr><h3 id="已知n-e-c在一般情况下（n可通过软件进行质因数分解）的解密"><a href="#已知n-e-c在一般情况下（n可通过软件进行质因数分解）的解密" class="headerlink" title="已知n,e,c在一般情况下（n可通过软件进行质因数分解）的解密"></a>已知n,e,c在一般情况下（n可通过软件进行质因数分解）的解密</h3><p>此时，我们有：</p><script type="math/tex; mode=display">n=p_1^{\alpha_1}p_2^{\alpha_2}p_3^{\alpha_3}\cdots p_k^{\alpha_k}(p_1,p_2,p_3,\cdots ,p_k为k个不同质数)</script><p>此时，由欧拉函数的性质，我们有：</p><script type="math/tex; mode=display">\varphi(n)=\varphi(p_1^{\alpha_1}) \varphi(p_2^{\alpha_2}) \varphi(p_3^{\alpha_3}) \cdots \varphi(p_k^{\alpha_k})(p_1,p_2,p_3,\cdots p_k是n的不同质因数，且有p_1^{\alpha_1}p_2^{\alpha_2}p_3^{\alpha_3}\cdots p_k^{\alpha_k}=n)</script><p>由欧拉函数的计算公式我们可以知道：</p><script type="math/tex; mode=display">\varphi(p^k)=p^k\prod_{i=1}^{k}\bigg(1-\frac{1}{p^i}\bigg)</script><p>所以对于<script type="math/tex">n</script>，有：</p><script type="math/tex; mode=display">\varphi(n)=\prod_{i=1}^{k}p_i^{\alpha_i}\prod_{j = 1}^{\alpha_i}\bigg(1-\frac{1}{p_i^j}\bigg)</script><p>特别的，对于质数<script type="math/tex">p</script>，有：</p><script type="math/tex; mode=display">\varphi(p)=p\bigg(1-\frac{1}{p}\bigg)=p-1</script><p>若<script type="math/tex">n</script>为<script type="math/tex">k</script>个不相同质数相乘，即：</p><script type="math/tex; mode=display">n=p_1p_2p_3\cdots p_k</script><p>有：</p><script type="math/tex; mode=display">\varphi(n)=(p_1-1)(p_2-1)(p_3-1)\cdots(p_k-1)</script><p>在一般情况下<script type="math/tex">n</script>只有两个质因数<script type="math/tex">p</script>和<script type="math/tex">q</script>，例如下题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime,bytes_to_long,long_to_bytes</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> gcd,invert</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">m=bytes_to_long(flag)</span><br><span class="line">p=<span class="number">274327862430236019688316864082249987313</span></span><br><span class="line">q=<span class="number">206961224895267889099693426679050192439</span></span><br><span class="line">n=p*q</span><br><span class="line">phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>,c)</span><br><span class="line"><span class="comment"># c = 54831930044859946955044417597501651143196043923856762253170140444376354297816</span></span><br></pre></td></tr></table></figure><p>这题直接给出了<script type="math/tex">p</script>和<script type="math/tex">q</script>，故我们只需要写出如下代码即可解决：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p = <span class="number">274327862430236019688316864082249987313</span></span><br><span class="line">q = <span class="number">206961224895267889099693426679050192439</span></span><br><span class="line">c = <span class="number">54831930044859946955044417597501651143196043923856762253170140444376354297816</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = p * q</span><br><span class="line">phi = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)<span class="comment">#求e模phi的乘法逆元</span></span><br><span class="line">m = gmpy2.powmod(c,d,n)<span class="comment">#等价于c^d mod n</span></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>运行即可得出flag：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;how_excellent_you_are!&#125;</span><br></pre></td></tr></table></figure><p>这就是最基本的RSA类型了。</p><h3 id="在已知e以及e组-n-c-的广播攻击"><a href="#在已知e以及e组-n-c-的广播攻击" class="headerlink" title="在已知e以及e组(n,c)的广播攻击"></a>在已知e以及e组(n,c)的广播攻击</h3><p>此类型攻击属于CRT（Chinese remainder theorem，中国剩余定理，又称孙子定理）类型。</p><p>原理不赘述，实质上即为已知<script type="math/tex">e</script>组<script type="math/tex">(n,c)</script>时利用CRT在不对任何一个<script type="math/tex">n</script>进行分解的情况下求解明文</p><p>在这里，我们设明文为<script type="math/tex">m</script>，有：</p><script type="math/tex; mode=display">\begin{cases}m^e\equiv c_1\ (mod\ n_1)\\m^e\equiv c_1\ (mod\ n_1)\\\ \ \ \ \ \ \ \ \ \ \ \ \ \vdots\\m^e\equiv c_e\ (mod\ n_e)\end{cases}\\\ \ \ (其中(n_1,c_1),(n_2,c_2),\cdots,(n_e,c_e)为e组不同的n与c)</script><p>再通过CRT求解出<script type="math/tex">m^e</script>后对其开<script type="math/tex">e</script>次方根即可得到明文<script type="math/tex">m</script></p><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><h6 id="鹤城杯-2021-Crazy-Rsa-Tech"><a href="#鹤城杯-2021-Crazy-Rsa-Tech" class="headerlink" title="[鹤城杯 2021]Crazy_Rsa_Tech"></a>[鹤城杯 2021]Crazy_Rsa_Tech</h6><p>题目代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">FLAG = bytes_to_long(pad(<span class="string">b&quot;flag&#123;??????&#125;&quot;</span>,<span class="number">64</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_key</span>():</span><br><span class="line">    p, q = getPrime(<span class="number">512</span>), getPrime(<span class="number">512</span>)</span><br><span class="line">    n = p*q</span><br><span class="line">    e = <span class="number">9</span></span><br><span class="line">    <span class="keyword">while</span>(GCD((p-<span class="number">1</span>)*(q-<span class="number">1</span>),e)!=<span class="number">1</span>):</span><br><span class="line">        p, q = getPrime(<span class="number">512</span>), getPrime(<span class="number">512</span>)</span><br><span class="line">        n = p*q</span><br><span class="line">    d = inverse(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> n,e,d</span><br><span class="line"></span><br><span class="line">n_list=<span class="built_in">list</span>()</span><br><span class="line">c_list=<span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    N,e,d=init_key()</span><br><span class="line">    n_list.append(N)</span><br><span class="line">    c=<span class="built_in">pow</span>(FLAG,e,N)</span><br><span class="line">    c_list.append(<span class="built_in">pow</span>(FLAG,e,N))</span><br><span class="line">    <span class="keyword">assert</span>(<span class="built_in">pow</span>(c,d,N)==FLAG)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n_list:&quot;</span>,n_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c_list:&quot;</span>,c_list)</span><br><span class="line"><span class="comment">#n_list= [71189786319102608575263218254922479901008514616376166401353025325668690465852130559783959409002115897148828732231478529655075366072137059589917001875303598680931962384468363842379833044123189276199264340224973914079447846845897807085694711541719515881377391200011269924562049643835131619086349617062034608799, 92503831027754984321994282254005318198418454777812045042619263533423066848097985191386666241913483806726751133691867010696758828674382946375162423033994046273252417389169779506788545647848951018539441971140081528915876529645525880324658212147388232683347292192795975558548712504744297104487514691170935149949, 100993952830138414466948640139083231443558390127247779484027818354177479632421980458019929149817002579508423291678953554090956334137167905685261724759487245658147039684536216616744746196651390112540237050493468689520465897258378216693418610879245129435268327315158194612110422630337395790254881602124839071919, 59138293747457431012165762343997972673625934330232909935732464725128776212729547237438509546925172847581735769773563840639187946741161318153031173864953372796950422229629824699580131369991913883136821374596762214064774480548532035315344368010507644630655604478651898097886873485265848973185431559958627423847, 66827868958054485359731420968595906328820823695638132426084478524423658597714990545142120448668257273436546456116147999073797943388584861050133103137697812149742551913704341990467090049650721713913812069904136198912314243175309387952328961054617877059134151915723594900209641163321839502908705301293546584147, 120940513339890268554625391482989102665030083707530690312336379356969219966820079510946652021721814016286307318930536030308296265425674637215009052078834615196224917417698019787514831973471113022781129000531459800329018133248426080717653298100515701379374786486337920294380753805825328119757649844054966712377, 72186594495190221129349814154999705524005203343018940547856004977368023856950836974465616291478257156860734574686154136925776069045232149725101769594505766718123155028300703627531567850035682448632166309129911061492630709698934310123778699316856399909549674138453085885820110724923723830686564968967391721281, 69105037583161467265649176715175579387938714721653281201847973223975467813529036844308693237404592381480367515044829190066606146105800243199497182114398931410844901178842049915914390117503986044951461783780327749665912369177733246873697481544777183820939967036346862056795919812693669387731294595126647751951, 76194219445824867986050004226602973283400885106636660263597964027139613163638212828932901192009131346530898961165310615466747046710743013409318156266326090650584190382130795884514074647833949281109675170830565650006906028402714868781834693473191228256626654011772428115359653448111208831188721505467497494581]</span></span><br><span class="line"><span class="comment">#c_list=[62580922178008480377006528793506649089253164524883696044759651305970802215270721223149734532870729533611357047595181907404222690394917605617029675103788705320032707977225447998111744887898039756375876685711148857676502670812333076878964148863713993853526715855758799502735753454247721711366497722251078739585, 46186240819076690248235492196228128599822002268014359444368898414937734806009161030424589993541799877081745454934484263188270879142125136786221625234555265815513136730416539407710862948861531339065039071959576035606192732936477944770308784472646015244527805057990939765708793705044236665364664490419874206900, 85756449024868529058704599481168414715291172247059370174556127800630896693021701121075838517372920466708826412897794900729896389468152213884232173410022054605870785910461728567377769960823103334874807744107855490558726013068890632637193410610478514663078901021307258078678427928255699031215654693270240640198, 14388767329946097216670270960679686032536707277732968784379505904021622612991917314721678940833050736745004078559116326396233622519356703639737886289595860359630019239654690312132039876082685046329079266785042428947147658321799501605837784127004536996628492065409017175037161261039765340032473048737319069656, 1143736792108232890306863524988028098730927600066491485326214420279375304665896453544100447027809433141790331191324806205845009336228331138326163746853197990596700523328423791764843694671580875538251166864957646807184041817863314204516355683663859246677105132100377322669627893863885482167305919925159944839, 2978800921927631161807562509445310353414810029862911925227583943849942080514132963605492727604495513988707849133045851539412276254555228149742924149242124724864770049898278052042163392380895275970574317984638058768854065506927848951716677514095183559625442889028813635385408810698294574175092159389388091981, 16200944263352278316040095503540249310705602580329203494665614035841657418101517016718103326928336623132935178377208651067093136976383774189554806135146237406248538919915426183225265103769259990252162411307338473817114996409705345401251435268136647166395894099897737607312110866874944619080871831772376466376, 31551601425575677138046998360378916515711528548963089502535903329268089950335615563205720969393649713416910860593823506545030969355111753902391336139384464585775439245735448030993755229554555004154084649002801255396359097917380427525820249562148313977941413268787799534165652742114031759562268691233834820996, 25288164985739570635307839193110091356864302148147148153228604718807817833935053919412276187989509493755136905193728864674684139319708358686431424793278248263545370628718355096523088238513079652226028236137381367215156975121794485995030822902933639803569133458328681148758392333073624280222354763268512333515]</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里很容易可以知道<script type="math/tex">e=9</script>（显而易见，<script type="math/tex">n</script>和<script type="math/tex">c</script>也有九组），所以很显然，这题要用到<script type="math/tex">e=9</script>的广播攻击</p><p>将上面给出的n_list和c_list用sagemath利用CRT求解得出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m9=<span class="number">3678337284039442047026947312380394506988284605153398380909870598085147736828709178219597429308046538374273111663234962853201175297522552444068549756304348183089003998584929250444862897734669616839072634559776823068102560978738392642133409979083241310818961120830565330801827594023873873703163937572703881578432281109467318674533265052430906776650900523035132668203491899352234368836316318216812572637893433384928785981896373747430646617935503364537613820302679656375356094380483213814869276308187497478084540603362678580814022322799191778371368875742773945120383365613028633102737056410926701477700008313642639347163933146129361496566648131161287075292980980083166106192999528561889437021539352391671756010617540361596164032486633114877739259434431765044242037641759566659268290619705700083536966807192023377334915872207418596226819579720241509860110741821630775501873143209229299530346706612248414951753383716954165108266753409813119293227854442685830689203424064786691447734948037502729127922328149002842971722645909768174575776908113523451541199095073733017029558396658874593357205426105429760517295964966905772455366037986657671195106462661190327510507460112791663031458690187525393979689469548319821181450874331998372947479866557921497942728807505035932385939931524294822439633516457845581452433022749099648076725811489217888688273759202726271093237450290814247396662589614216704</span><span class="comment">#m9为m的9次方</span></span><br></pre></td></tr></table></figure><p>再对<script type="math/tex">m9</script>开9次方根可得：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m=<span class="number">5364346700993245916083351542951836466599376039702798829478182513243184146028312538778801523615449405915572188751896617305936540801999004614344621214275094</span></span><br></pre></td></tr></table></figure><p>再通过Crypto库中long_to_bytes函数可得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;H0w_Fun_13_HAstads_broadca5t_AtTack!&#125;</span><br></pre></td></tr></table></figure><h3 id="gcd类型"><a href="#gcd类型" class="headerlink" title="gcd类型"></a>gcd类型</h3><p>这种类型主要考察数学推导的能力，直接上例题。</p><h4 id="GKCTF-2021-RRRRsa-1（部分）"><a href="#GKCTF-2021-RRRRsa-1（部分）" class="headerlink" title="[GKCTF 2021]RRRRsa 1（部分）"></a>[GKCTF 2021]RRRRsa 1（部分）</h4><p>题目代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pbits = <span class="number">512</span></span><br><span class="line">p, q = getPrime(pbits), getPrime(pbits)</span><br><span class="line">n = p * q</span><br><span class="line">hint1 = <span class="built_in">pow</span>(<span class="number">2020</span> * p + q, <span class="number">202020</span>, n)</span><br><span class="line">hint2 = <span class="built_in">pow</span>(<span class="number">2121</span> * p + <span class="number">212121</span>, q, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;n = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;hint1 = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;hint2 = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n =</span></span><br><span class="line"><span class="string">72480597722768310802103225074022304502987810353239303491995392556828592827312126864102279719480413772239054950810362120660174703790228376146053986053171930937388580526219104498648291397309599209554202670080978901954049943834889894306222459711036629282482760872552358198065124168348275611897584923869319730917</span></span><br><span class="line"><span class="string">hint1 =</span></span><br><span class="line"><span class="string">70685159982753618117937078087626553902610663214529331305611406765104333038200912863267956767277081926123480288270862897047313253820275507292683667878994502600957911694615683337770022569861106230373836250952155917286151237134316356851059293688768775787985566372022900108303136666429150678266857778726967849907</span></span><br><span class="line"><span class="string">hint2 =</span></span><br><span class="line"><span class="string">59397395285145715354919882069200896861665631746130494855994590508589325004636436593048816842106180115714527211321251497281171549276111388361451000025849056493942252398618018816656979043710894623882099581494083699322411790446784391932055982624616996747139852037848608960801937270797966812928286289985647495610</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以知道：</p><script type="math/tex; mode=display">hint1\equiv (2020p+q)^{202020}\ (mod\ n)\\hint2\equiv (2121p+212121)^{q}\ (mod\ n)</script><p>我们要从上面两个方程中求解<script type="math/tex">p</script>和<script type="math/tex">q</script>，下面进行数学推导：</p><p>首先观察hint1，由二项式定理有：</p><script type="math/tex; mode=display">(2020p+q)^{202020}=(2020p)^{202020}+(2020p)^{202019}q+\cdots+2020pq^{202019}+q^{202020}</script><p>显然的，右式除<script type="math/tex">(2020p)^{202020}</script>与<script type="math/tex">q^{202020}</script>两项外均能被<script type="math/tex">n</script>整除</p><p>所以有：</p><script type="math/tex; mode=display">hint1\equiv (2020p)^{202020}+q^{202020}\ (mod\ n)</script><p>进一步的，有：</p><script type="math/tex; mode=display">hint1\equiv(2020p)^{202020}\ (mod\ q)</script><p>现在看到hint2，有：</p><script type="math/tex; mode=display">hint2\equiv (2121p+212121)^q\ (mod\ q)</script><p>由费马小定理，可以得到：</p><script type="math/tex; mode=display">hint2\equiv 2121p+212121\ (mod\ q)</script><p>所以：</p><script type="math/tex; mode=display">(hint2-212121)^{202020}(2020)^{202020}\equiv (2020\cdot2021p)^{202020}\ (mod\ q)</script><p>对于hint1：</p><script type="math/tex; mode=display">hint1(2121)^{202020}\equiv (2020\cdot2021p)^{202020}\ (mod\ q)</script><p>故：</p><script type="math/tex; mode=display">hint1(2121)^{202020}-(hint2-212121)^{202020}(2020)^{202020}\equiv 0\ (mod\ q)</script><p>所以有：</p><script type="math/tex; mode=display">kq=hint1(2121)^{202020}-(hint2-212121)^{202020}(2020)^{202020}</script><p>由于<script type="math/tex">n=pq</script></p><p>所以<script type="math/tex">gcd(kq,n)=</script></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">n = <span class="number">72480597722768310802103225074022304502987810353239303491995392556828592827312126864102279719480413772239054950810362120660174703790228376146053986053171930937388580526219104498648291397309599209554202670080978901954049943834889894306222459711036629282482760872552358198065124168348275611897584923869319730917</span></span><br><span class="line">hint1 = <span class="number">70685159982753618117937078087626553902610663214529331305611406765104333038200912863267956767277081926123480288270862897047313253820275507292683667878994502600957911694615683337770022569861106230373836250952155917286151237134316356851059293688768775787985566372022900108303136666429150678266857778726967849907</span></span><br><span class="line">hint2 = <span class="number">59397395285145715354919882069200896861665631746130494855994590508589325004636436593048816842106180115714527211321251497281171549276111388361451000025849056493942252398618018816656979043710894623882099581494083699322411790446784391932055982624616996747139852037848608960801937270797966812928286289985647495610</span></span><br><span class="line">kq = gmpy2.powmod(<span class="number">2121</span>,<span class="number">202020</span>,n)*hint1-gmpy2.powmod((hint2-<span class="number">212121</span>)*<span class="number">2020</span>,<span class="number">202020</span>,n)</span><br><span class="line">q = gmpy2.gcd(kq,n)</span><br><span class="line"><span class="built_in">print</span>(q)</span><br></pre></td></tr></table></figure><p>这样就得出了<script type="math/tex">q</script>，由此我们就可以顺带求出<script type="math/tex">p</script>了。</p><p>（还有道题是Geek Challenge 2023的Poly_RSA，但是在写笔记的时候比赛还没结束，就不放出来了，后面写wp的时候再讲推导过程）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在进行RSA解密之前，我们先要理解RSA的加密原理：&lt;/p&gt;
&lt;p&gt;已知明文&lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;，公钥对&lt;script type=&quot;math/tex&quot;&gt;(n,e)&lt;/script&gt;，加密过程如下:&lt;/p&gt;
&lt;script ty</summary>
      
    
    
    
    <category term="密码学笔记" scheme="https://triodelzx.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Crypto" scheme="https://triodelzx.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>深大Aurora第一批入队赛WP</title>
    <link href="https://triodelzx.github.io/2023/11/11/%E6%B7%B1%E5%A4%A7Aurora%E7%AC%AC%E4%B8%80%E6%89%B9%E5%85%A5%E9%98%9F%E8%B5%9BWP/"/>
    <id>https://triodelzx.github.io/2023/11/11/%E6%B7%B1%E5%A4%A7Aurora%E7%AC%AC%E4%B8%80%E6%89%B9%E5%85%A5%E9%98%9F%E8%B5%9BWP/</id>
    <published>2023-11-11T11:37:13.000Z</published>
    <updated>2023-11-12T05:28:49.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><hr><h2 id="简单丢番图方程（解题成本最高的一道）"><a href="#简单丢番图方程（解题成本最高的一道）" class="headerlink" title="简单丢番图方程（解题成本最高的一道）"></a>简单丢番图方程（解题成本最高的一道）</h2><p>（其实就是一道二元二次不定方程问题）</p><p>这题是十分简单的，因为数值不大，所以用手机或者电脑计算器都可以解决.</p><p>刚开始代码还没撤掉的时候我就开始做了，而那个时候我还不会用靶机，所以导致求解出来的flag是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;None&#125;</span><br></pre></td></tr></table></figure><p>我以为这是对的，交上去发现是错的</p><p>后来问了学长学姐知道靶机大概怎么用，就做出来了，解题步骤大致如下：</p><h3 id="打开虚拟机（这是要讲的吗）"><a href="#打开虚拟机（这是要讲的吗）" class="headerlink" title="打开虚拟机（这是要讲的吗）"></a>打开虚拟机<del>（这是要讲的吗）</del></h3><h3 id="在虚拟机中打开靶机"><a href="#在虚拟机中打开靶机" class="headerlink" title="在虚拟机中打开靶机"></a>在虚拟机中打开靶机</h3><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938767.png" alt="picture1"></p><h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>在这里我们可以看到一个比较大的数和一条很像勾股定理的方程，所以我们可以断定这题要用到勾股定理，而我们知道的勾股数就那么几对，所以我们可以通过质因数分解找出我们熟悉的勾股数，现在我们打开factordb，将这个已知的数进行质因数分解，结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938627.png" alt="picture2"></p><p>啊？怎么是个质数？运气太差了吧QwQ（我发誓不是节目效果）</p><p>遇到这种情况，我们直接重开一把（这个数是随机生成的）</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938955.png" alt="picture3"></p><p>这回就出来了</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938258.png" alt="picture4"></p><p>不幸的是，对于这个数的较小质因数4289，我们好像很难找出一组适合的勾股数（不一定是不存在，就是难找）</p><p>那么再重开一把：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111924525.png" alt="picture5"></p><p>很好，这次质因数分解后得到了我们想要的小质数</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111924541.png" alt="picture6"></p><p>而我们知道</p><script type="math/tex; mode=display">(5,12,13)</script><p>是一组常见的勾股数，所以我们丢进计算器中可以算出：</p><script type="math/tex; mode=display">x=304168011786560/5*12=730003228287744</script><script type="math/tex; mode=display">y=304168011786560/5*13=790836830645056</script><p>这个时候我们把结果提交到靶机就可以得到我们想要的flag啦！</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938758.png" alt="final"></p><h4 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;ebd8bc51-2d57-406e-bcab-f601cfcb6924&#125;</span><br></pre></td></tr></table></figure><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>这道题我觉得要改进的话应该数字搞大一点，锻炼Python编程能力</p><hr><h2 id="baby-RSA"><a href="#baby-RSA" class="headerlink" title="baby_RSA"></a>baby_RSA</h2><p>这题还是比较简单的，只涉及到大数分解问题</p><p>先贴一下加密的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;Aurora&#123;**************************&#125;&#x27;</span></span><br><span class="line">secret = bytes_to_long(flag)</span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    p = getPrime(<span class="number">64</span>)</span><br><span class="line">    n *= p</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;n = &#x27;</span>, n)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="built_in">pow</span>(secret, e, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;e = &#x27;</span>, e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c = &#x27;</span>, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n =  2569145024684622683457290566739578718781018607677133574327822751866674386502335246000317890583553843099438656104623280209350573717179549184696858107986816661639787132730364636194737009459824271476498027756348528217194276155711650247369034548196806275337131198343225513266990652767612936625004781028669059369</span></span><br><span class="line"><span class="string">e = 65537</span></span><br><span class="line"><span class="string">c =  1020931685015452202981916444803667236245024365160728331275426090579241677721904274025513431759498012955573244224145411453713611725428207417310704905740410704428638374677350019810588412317867821915898434420902301522656261322329767378054642514078506001685079483518667410297164506433749115446356064877824980088</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>在《初等数论（第四版）》（闵嗣鹤，严士健编）对于RSA公钥体系的描述中（应该很多讲密码的书都是这样）</p><script type="math/tex; mode=display">n=pq(p,q是两个大质数)</script><p>但是将上面的n丢进factordb（谢谢学姐提供的数据）之后，它出现了16个不同的质因数（其实从代码中也可以看出）！那要怎么办呢？</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938273.png" alt="picture1"></p><p>实际上，在RSA公钥体系中，将密码转化为明码需要求解下列同余方程</p><script type="math/tex; mode=display">b^d\equiv a^{ed}\equiv a^{1+k\varphi(n)}(modn)(e为密钥，n为解钥，b为密码，a为明码)</script><p>而对于欧拉函数，有如下定理：</p><script type="math/tex; mode=display">\varphi(n)=\varphi(p_1^{\alpha_1}) \varphi(p_2^{\alpha_2}) \varphi(p_3^{\alpha_3}) \cdots \varphi(p_k^{\alpha_k})(p_1,p_2,p_3,\cdots p_k是n的不同质因数，且有p_1^{\alpha_1}p_2^{\alpha_2}p_3^{\alpha_3}\cdots p_k^{\alpha_k}=n)</script><p>而对于质数p，其欧拉函数值为：</p><script type="math/tex; mode=display">\varphi(p)=p-1</script><p>所以对于对于题中解钥n，有：</p><script type="math/tex; mode=display">\varphi(n)=(p_1-1)(p_2-1)(p_3-1)\cdots(p_{16}-1)(p_1,p_2,p_3,\cdots,p_{16}为n的16个不同的质因数</script><p>所以我们可以写出获得flag的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p1=<span class="number">11032741923171941087</span></span><br><span class="line">p2=<span class="number">11545653624202476473</span></span><br><span class="line">p3=<span class="number">11636293469353905931</span></span><br><span class="line">p4=<span class="number">11791412171539768003</span></span><br><span class="line">p5=<span class="number">12072682976194265431</span></span><br><span class="line">p6=<span class="number">12286985218370609161</span></span><br><span class="line">p7=<span class="number">13979567880622268887</span></span><br><span class="line">p8=<span class="number">14381447749489789777</span></span><br><span class="line">p9=<span class="number">14487171289353351409</span></span><br><span class="line">p10=<span class="number">14573688259437788669</span></span><br><span class="line">p11=<span class="number">15652738194884126429</span></span><br><span class="line">p12=<span class="number">16034270403328241087</span></span><br><span class="line">p13=<span class="number">16631285257180468447</span></span><br><span class="line">p14=<span class="number">17327252249988599903</span></span><br><span class="line">p15=<span class="number">17905457523849945107</span></span><br><span class="line">p16=<span class="number">18027152598391207147</span></span><br><span class="line">n=<span class="number">2569145024684622683457290566739578718781018607677133574327822751866674386502335246000317890583553843099438656104623280209350573717179549184696858107986816661639787132730364636194737009459824271476498027756348528217194276155711650247369034548196806275337131198343225513266990652767612936625004781028669059369</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">c=<span class="number">1020931685015452202981916444803667236245024365160728331275426090579241677721904274025513431759498012955573244224145411453713611725428207417310704905740410704428638374677350019810588412317867821915898434420902301522656261322329767378054642514078506001685079483518667410297164506433749115446356064877824980088</span></span><br><span class="line">phi=(p1-<span class="number">1</span>)*(p2-<span class="number">1</span>)*(p3-<span class="number">1</span>)*(p4-<span class="number">1</span>)*(p5-<span class="number">1</span>)*(p6-<span class="number">1</span>)*(p7-<span class="number">1</span>)*(p8-<span class="number">1</span>)*(p9-<span class="number">1</span>)*(p10-<span class="number">1</span>)*(p11-<span class="number">1</span>)*(p12-<span class="number">1</span>)*(p13-<span class="number">1</span>)*(p14-<span class="number">1</span>)*(p15-<span class="number">1</span>)*(p16-<span class="number">1</span>)<span class="comment">#很蠢的方法，一个一个填</span></span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line">m = gmpy2.powmod(c, d, n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>运行程序，我们就可以得到flag啦！</p><h4 id="flag-1"><a href="#flag-1" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;RS4_1s_r3a1y_fun_4nd_ea5y!&#125;</span><br></pre></td></tr></table></figure><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>善用百度，Python真好用，还有，数论真好玩。</p><hr><h2 id="你爱深大吗"><a href="#你爱深大吗" class="headerlink" title="你爱深大吗"></a>你爱深大吗</h2><p>（最抽象的一道）</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938612.png" alt="picture1"></p><h3 id="解题过程及思路"><a href="#解题过程及思路" class="headerlink" title="解题过程及思路"></a>解题过程及思路</h3><p>这本质上是一道阅读题</p><p>刚开始，我看到下面的藏宝图这么抽象，我就知道：这题必有Base100！</p><p>后来再看一眼上面的小作文，我在里面找到了偏移值为6的凯撒密码，18层栅栏密码和一个密钥为”iloveszu”的维吉尼亚密码</p><p>故我试着解密</p><p>解密过程：Base100-&gt;偏移值为6的凯撒密码-&gt;18层的栅栏密码-&gt;密钥为”iloveszu”的维吉尼亚密码</p><p>解密出来长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;JTpnwk$VLB%p:?CR&amp;QIH:]An&gt;Zz;#CAg&lt;f37;$IZXvZ2INm;MS\0@Cg`c@It4892#G?&lt;mftRsQ,t;&gt;Fsxd&lt;2o_&#x27;:f@TSj&gt;!&#x27;BM+%`5&gt;$&quot;.qrET&lt;K9vaE?@W`&quot;1;89%@JbhgeACT9$;3KE\&lt;O9n(;aNA!@5tl1;WiC@5=BJX:];z-&gt;5/(V;7&lt;Gk_V%.!&lt;i:#?=tJOu*g/@s97T(E=n&#x27;%GJMF):M8</span><br></pre></td></tr></table></figure><p>这一看就不是flag</p><p>后来（一天后）经过指点及思考我发现了“冲破了基地的重重阻碍”中的“重重”二字，所以就尝试一下多重Base解码吧</p><p>经过尝试，对“Base”步骤解码过程如下：</p><p>Base100-&gt;Base85-&gt;Base64-&gt;Base58-&gt;Base32</p><h5 id="解码结果："><a href="#解码结果：" class="headerlink" title="解码结果："></a>解码结果：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bky__cuuiwlz_zpwo&#123;taIkppbxywe__w&#125;st_hupzodnzht__t_ymhcicpfm</span><br></pre></td></tr></table></figure><p>解码出来发现出现了花括号和下划线，证明步骤应该是对了。</p><p>继续解密</p><p>根据上面的步骤，我们继续这条从偏移值为6的凯撒密码到18层的栅栏密码再到密钥为”iloveszu”的维吉尼亚密码的解密过程</p><p>解密出来如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N_r_uHfa_&#125;_kdt_hioaerz&#123;wkc_rxbitfvoeowgpfyddmvpol__qil_kbra</span><br></pre></td></tr></table></figure><p>完全不对，连格式（Aurora{<em>_</em>}）都不对，而上面的加密方式中而可以改变符号位置的只有栅栏密码，而我在搜索引擎里面发现了一种不同的栅栏密码——W型。</p><p>在尝试之后，我发现再次经过上述解码方式后得出了如下字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nhihpr&#123;Dpk_bacj_eaik_wvs_mdfti_fa_j_knuomyddm_bu_movvgjjjh&#125;</span><br></pre></td></tr></table></figure><p>格式总算是正确了，但是为什么连关键的Aurora都没有出现呢？</p><p>我发现可能是凯撒密码的问题</p><p>后来我尝试偏移值为666的凯撒密码（实际上偏移值是16）</p><p>然后再进行上述步骤得到了如下字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dxyxfh&#123;Tfa_rqsz_uqya_mli_ctvjy_vq_z_adkecottc_rk_cellwzzzx&#125;</span><br></pre></td></tr></table></figure><p>发现还是不对</p><p>退回维吉尼亚密码前一步，我发现在解维吉尼亚密码之前的密文是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Limsjz&#123;Szi_cend_mpsi_xzd_gludg_ge_u_evjykzhog_jj_wmwzrdryr&#125;</span><br></pre></td></tr></table></figure><p>第一个是L，对照维吉尼亚密码表，我们可以发现，如果要从A得到L（因为我们猜测明文的第一个字母为A），那么密钥应为L</p><p>也就是说，维吉尼亚密码的密钥开头应该为L而不是I</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111928296.png" alt="密码表"></p><p>再次解密，得到如下字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;You_have_seen_the_magic_of_a_thousands_of_encodings&#125;</span><br></pre></td></tr></table></figure><p>这个就是flag了。</p><p>所以这道题的步骤为：</p><h3 id="Base100-gt-Base85-gt-Base64-gt-Base58-gt-Base32-gt-偏移值为666（即16）的凯撒密码-gt-18层的W型栅栏密码-gt-密钥为”loveszu”的维吉尼亚密码"><a href="#Base100-gt-Base85-gt-Base64-gt-Base58-gt-Base32-gt-偏移值为666（即16）的凯撒密码-gt-18层的W型栅栏密码-gt-密钥为”loveszu”的维吉尼亚密码" class="headerlink" title="Base100-&gt;Base85-&gt;Base64-&gt;Base58-&gt;Base32-&gt;偏移值为666（即16）的凯撒密码-&gt;18层的W型栅栏密码-&gt;密钥为”loveszu”的维吉尼亚密码"></a>Base100-&gt;Base85-&gt;Base64-&gt;Base58-&gt;Base32-&gt;偏移值为666（即16）的凯撒密码-&gt;18层的W型栅栏密码-&gt;密钥为”loveszu”的维吉尼亚密码</h3><hr><h2 id="AAAEEESSS"><a href="#AAAEEESSS" class="headerlink" title="AAAEEESSS"></a>AAAEEESSS</h2><p>先读代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag   </span><br><span class="line"><span class="comment">#flag从一个神秘的地方获得</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key = <span class="string">b&#x27;welcometoAurora!&#x27;</span></span><br><span class="line">aes = AES.new(key, AES.MODE_CBC, iv=key)</span><br><span class="line">aes.encrypt(pad(<span class="string">b&#x27;Could u solve this challenge?&#x27;</span>, <span class="built_in">len</span>(key)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;enc_flag = &quot;</span>, aes.encrypt(pad(flag, <span class="built_in">len</span>(key))).<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">enc_flag =  de4c9776943ff87949bb89d40993000142b59e38b75e2d4c3719cb37f164c0e5</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>我们会发现这是CBC模式的AES加密，flag可能是下面的16进制字串解密而来的，通过搜索，我们发现有一个工具可以解密AES：</p><p><a href="https://www.mklab.cn/utils/aes">AES在线加密解密工具 - MKLab在线工具</a></p><p>而阅读上面的代码，我们可以知道偏移向量和密钥均为<u>welcometoAurora!</u>将这两个东西放进去对应的地方，解码发现他出现了如下乱码:</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111928937.png" alt="解密1"></p><p>是否是我的方法出了问题呢？</p><p>继续读代码，我们可以看到一个刚才被忽略的东西：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aes.encrypt(pad(<span class="string">b&#x27;Could u solve this challenge?&#x27;</span>, <span class="built_in">len</span>(key)))</span><br></pre></td></tr></table></figure><p>这串代码我们可以猜测是在Could u slove this challenge?加密后16进制字串后面拼接一条什么东西（AES加密的填充机制和密码长度规律）。</p><p>所以我们可以试着先将Could u slove this challenge?进行AES加密，得到如下密文串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">83e3e72c29293db45cb82f2d0c71613c18ae88de339c7280cfed4a5122106546</span><br></pre></td></tr></table></figure><p>在后面拼接代码中enc_flag部分如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">83e3e72c29293db45cb82f2d0c71613c18ae88de339c7280cfed4a5122106546de4c9776943ff87949bb89d40993000142b59e38b75e2d4c3719cb37f164c0e5</span><br></pre></td></tr></table></figure><p>再放入密码输入框中解密可得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could u solve this challenge?Aurora&#123;f1nd_th3_5ecr3t_0f_aes&#125;</span><br></pre></td></tr></table></figure><p>这样就得到了flag：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;f1nd_th3_5ecr3t_0f_aes&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="qsdz的密码学衔接课（赛后复现）"><a href="#qsdz的密码学衔接课（赛后复现）" class="headerlink" title="qsdz的密码学衔接课（赛后复现）"></a>qsdz的密码学衔接课（赛后复现）</h2><p>这题由三小题组成，分别是：求解同余方程，求解同余方程组，求解离散对数问题。</p><p>而这三个问题，我们都要利用到一个重要工具：sagemath</p><p>下面我们分别求解三个问题：</p><h3 id="同余方程"><a href="#同余方程" class="headerlink" title="同余方程"></a>同余方程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">challenge1</span>(<span class="params">x: <span class="built_in">int</span>, order: <span class="built_in">int</span></span>):</span><br><span class="line">    p = getPrime(x.bit_length() * order)</span><br><span class="line">    A = [getPrime(x.bit_length()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(order)]</span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(order):</span><br><span class="line">        y = (y + A[i] * x ** i) % p</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=&#x27;</span> * <span class="number">10</span> + <span class="string">&#x27;Challenge 1&#x27;</span> + <span class="string">&#x27;=&#x27;</span> * <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;p = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;A = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;y = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">==========Challenge 1==========</span></span><br><span class="line"><span class="string">p = 140540932516518794145151934666843219294863335242957071370416678765850106203805810862867703792863302163318519910426474343219910841109958974959958710112904675289540046802486139135135963299678067328274525866708889478446402107588914151782335913</span></span><br><span class="line"><span class="string">A = [586077106161933115521158870621277482378849813647,</span></span><br><span class="line"><span class="string">594177621805167358745968527276343722485294425499, </span></span><br><span class="line"><span class="string">438154568295734958683230212377930413557186542591,</span></span><br><span class="line"><span class="string">613916554223827544243334495150247792479839893207,</span></span><br><span class="line"><span class="string">696514075788803577127407605798057483933441939039]</span></span><br><span class="line"><span class="string">y = 13584348643332560556129513295162939264971165296317907991475444036286814596235852842416707036226141464730561542976865467336771619592932663214739700885173786520323855676418761763774305698027356758972580332479097742926600081856865297421280491</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>可以看出，这里的同余方程为：</p><script type="math/tex; mode=display">A_0+A_1x+A_2x^2+A_3x^3+A_4x^4\equiv y(mod\ p)</script><p>所以我们在sagemath中对该方程做出如下定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R.&lt;x&gt;=Zmod(p)[]</span><br><span class="line">f=A[<span class="number">0</span>]+A[<span class="number">1</span>]*x+A[<span class="number">2</span>]*x^<span class="number">2</span>+A[<span class="number">3</span>]*x^<span class="number">3</span>+A[<span class="number">4</span>]*x^<span class="number">4</span>-y</span><br></pre></td></tr></table></figure><p>再通过下面一段代码进行求解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.roots()</span><br></pre></td></tr></table></figure><p>可以得出下面两个解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x_1=98641516410644248590730760547711915061873706589456407188998882763190683930094458978790759787796637145415287953931944776332655673057814076619504993207500838191433321143407475719143239135946766090781645970151825507798503659865125167544876679</span><br><span class="line">x_2=373703556015754746532223260569877349038577184359</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至于是哪个解，我们到后面再讨论。</p><h3 id="同余方程组"><a href="#同余方程组" class="headerlink" title="同余方程组"></a>同余方程组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">challenge2</span>(<span class="params">x: <span class="built_in">int</span>, number: <span class="built_in">int</span></span>):</span><br><span class="line">    ps = [getPrime(x.bit_length() // (number - <span class="number">1</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(number)]</span><br><span class="line">    ys = [x % p <span class="keyword">for</span> p <span class="keyword">in</span> ps]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=&#x27;</span> * <span class="number">10</span> + <span class="string">&#x27;Challenge 2&#x27;</span> + <span class="string">&#x27;=&#x27;</span> * <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;ps = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;ys = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">ps = [288186237701, 283710289297, 488405307827, 284002449103, 433963503397]</span></span><br><span class="line"><span class="string">ys = [229627846199, 206465857548, 461943583630, 18924375666, 173733924485]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>我们很容易可以写出上述代码的等价方程组：</p><script type="math/tex; mode=display">\begin{cases}        x\equiv229627846199(mod\ 288186237701)\\        x\equiv206465857548(mod\ 283710289297)\\        x\equiv461943583630(mod\ 488405307827)\\        x\equiv18924375666(mod\ 284002449103)\\        x\equiv173733924485(mod\ 433963503397)\end{cases}</script><p>求解这种传统不定方程组需要利用一个定理——孙子定理（中国剩余定理/CRT），在sagemath中输入下列指令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crt(ys,ps)</span><br></pre></td></tr></table></figure><p>可以得到下列解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">653438615351908597859575533851627354929851494003</span><br></pre></td></tr></table></figure><p>设上面的数字为y，则上述方程组等价于：</p><script type="math/tex; mode=display">x\equiv y(mod\ ps_0ps_1ps_2ps_3ps_4)</script><p>我们可以验证：</p><script type="math/tex; mode=display">gcd(y,ps_0ps_1ps_2ps_3ps_4)=1</script><p>根据同余方程的性质，我们可以知道还有其他的解：</p><script type="math/tex; mode=display">y+k\cdot ps_0ps_1ps_2ps_3ps_4\equiv y(mod\ ps_0ps_1ps_2ps_3ps_4)</script><p>先假定需要的解就是上面的y。</p><h3 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h3><p><del>又是同余方程</del></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">challenge3</span>(<span class="params">x: <span class="built_in">int</span></span>):</span><br><span class="line">    base = getPrime(x.bit_length())</span><br><span class="line">    exp = getRandomInteger(<span class="number">40</span>)</span><br><span class="line">    module = getPrime(x.bit_length())</span><br><span class="line">    y = <span class="built_in">pow</span>(base, exp, module)</span><br><span class="line">    cipher = exp * x % module</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=&#x27;</span> * <span class="number">10</span> + <span class="string">&#x27;Challenge 3&#x27;</span> + <span class="string">&#x27;=&#x27;</span> * <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;base = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;module = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;y = &#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;cipher = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">base = 410736349593916097049313683889292166618005625707</span></span><br><span class="line"><span class="string">module = 644953605408967844199642272144415528955561551061</span></span><br><span class="line"><span class="string">y = 242650313731015062596916881403616976177380555988</span></span><br><span class="line"><span class="string">cipher = 398635925008029999138603615357303867027885126384</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>求解上述离散对数，其实就是求解下列同余方程：</p><script type="math/tex; mode=display">base^{exp}\equiv y(mod\ module)</script><p>而上述方程中，又有：</p><script type="math/tex; mode=display">exp\cdot x\equiv cipher(mod\ module)</script><p>现在我们要求解未知数x，所以我们需要先求出exp</p><p>在sagemath中使用以下指令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp = discrete_log_lambda(mod(y, module), mod(base, module), bounds=(<span class="number">2</span>**<span class="number">39</span>, <span class="number">2</span>**<span class="number">40</span>))</span><br></pre></td></tr></table></figure><p>可得</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp=<span class="number">940420210186</span></span><br></pre></td></tr></table></figure><p>再通过下面的指令求出x：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cipher * inverse_mod(exp, module) % module</span><br></pre></td></tr></table></figure><p>可得解为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">545012220020390134376571283157248116812656615805</span><br></pre></td></tr></table></figure><h3 id="结合"><a href="#结合" class="headerlink" title="结合"></a>结合</h3><p>阅读题中代码的最上面部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">b&#x27;Aurora&#123;qsdzyyds&#125;&#x27;</span></span><br><span class="line">part_number = <span class="built_in">len</span>(flag) // <span class="number">3</span></span><br><span class="line">flag_part1 = bytes_to_long(flag[:part_number])</span><br><span class="line">flag_part2 = bytes_to_long(flag[part_number:<span class="number">2</span>*part_number])</span><br><span class="line">flag_part3 = bytes_to_long(flag[<span class="number">2</span>*part_number:])</span><br></pre></td></tr></table></figure><p>我们可以知道，flag的三部分应该长度一致，所以对于同余方程与同余方程组部分的解应该与离散对数相同，所以有：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag1=<span class="number">373703556015754746532223260569877349038577184359</span></span><br><span class="line">flag2=<span class="number">653438615351908597859575533851627354929851494003</span></span><br><span class="line">flag3=<span class="number">545012220020390134376571283157248116812656615805</span></span><br></pre></td></tr></table></figure><p>我们可以通过下面的代码求出flag：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(long_to_bytes(flag1))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(flag2))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(flag3))</span><br></pre></td></tr></table></figure><p>可以得出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;Aurora&#123;Sagem4th&amp;c0ng&#x27;</span></span><br><span class="line"><span class="string">b&#x27;ru3nce_and_e9uations&#x27;</span></span><br><span class="line"><span class="string">b&#x27;_w1th_di5crete_lOg!&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="flag-2"><a href="#flag-2" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;Sagem4th&amp;c0ngru3nce_and_e9uations_w1th_di5crete_lOg!&#125;</span><br></pre></td></tr></table></figure><p>至此，衔接题就解决了。</p><hr><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><hr><h2 id="Basic-nc"><a href="#Basic-nc" class="headerlink" title="[Basic]nc"></a>[Basic]nc</h2><p>直接打开靶机</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938881.png" alt="picture1"></p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111931005.png" alt="picture2"></p><p>看到有个flag，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat flag</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938471.png" alt="picture3"></p><p>flag就出来了。</p><h4 id="flag-3"><a href="#flag-3" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;ce8bf21a-3c2e-49f3-b27b-86440b8e8dd9&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Advanced-寰宇蝗灾"><a href="#Advanced-寰宇蝗灾" class="headerlink" title="[Advanced]寰宇蝗灾"></a>[Advanced]寰宇蝗灾</h2><p><del>（我就想玩个游戏，为什么会拿到这题的一血）</del></p><p>直接打开靶机！</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938268.png" alt="picture1"></p><p>直接攻击</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938360.png" alt="picture2"></p><p>玩着玩着虫子的数量出现了负数，这个时候我们就可以知道，这题利用的是数据溢出的漏洞，那我们逮着这个漏洞打就行了，多打几遍就会出现下面的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938852.png" alt="picture3"></p><p>还真是溢出<del>（至于怎么溢出的我也不清楚）</del></p><p>现在flag就出来了。</p><h4 id="flag-4"><a href="#flag-4" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;8fae9274-d452-4f64-966e-024584b8a8d1&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><hr><h2 id="Basic-消失的原神"><a href="#Basic-消失的原神" class="headerlink" title="[Basic]消失的原神"></a>[Basic]消失的原神</h2><p><del>（我刚开始真的以为下载个原神就可以拿到flag）</del></p><p>首先将消失的原神.exe文件拖到ida64中</p><p>按下Shift+F12进入string页面</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111932558.png" alt="picture1"></p><p>上面就是我们要的flag了</p><h4 id="flag-5"><a href="#flag-5" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;D0_u_P1a_G3nsh1n_iMpact&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Basic-148464"><a href="#Basic-148464" class="headerlink" title="[Basic]148464"></a>[Basic]148464</h2><p>先拖进ida64，直接飞去main按F5进行一个编译</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938413.png" alt="picture1"></p><p>观察下列代码我们可以看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;zMXHz9T6sdfZx8LtxZn0x8jHC8vFnJr3&quot;</span>) )</span><br></pre></td></tr></table></figure><p>发现flag在一系列未知的操作后变成了字符串”zMXHz9T6sdfZx8LtxZn0x8jHC8vFnJr3”。</p><p>现在我们要找到flag怎么变才能变成上述字符串。</p><p>我们阅读如下代码，可知flag是一个长度为24的字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input your flag:&quot;</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%24s&quot;</span>, s);</span><br></pre></td></tr></table></figure><p>再次阅读代码，我们发现s被丢进下面的函数里面进行过操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( v5 - <span class="number">2</span> &gt; dword_4124 )</span><br><span class="line"> &#123;</span><br><span class="line">    sub_12F0((<span class="type">unsigned</span> <span class="type">int</span>)s[dword_4124], (<span class="type">unsigned</span> <span class="type">int</span>)s[dword_4124 + <span class="number">1</span>], (<span class="type">unsigned</span> <span class="type">int</span>)s[dword_4124 + <span class="number">2</span>]);</span><br><span class="line">    dword_4124 += <span class="number">3</span>;</span><br><span class="line">    dword_4128 += <span class="number">4</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>双击进入函数sub_12F0，我们看到这个函数进行的是如下操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_12F0</span><span class="params">(<span class="type">char</span> a1, <span class="type">char</span> a2, <span class="type">char</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  </span><br><span class="line">  s1[dword_4128] = aAbcdefghijklmn[a1 &gt;&gt; <span class="number">2</span>];</span><br><span class="line">  s1[dword_4128 + <span class="number">1</span>] = aAbcdefghijklmn[((<span class="type">unsigned</span> __int8)(<span class="number">16</span> * a1) | (<span class="type">unsigned</span> __int8)(a2 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x3F</span>];</span><br><span class="line">  s1[dword_4128 + <span class="number">2</span>] = aAbcdefghijklmn[((<span class="type">unsigned</span> __int8)(<span class="number">4</span> * a2) | (<span class="type">unsigned</span> __int8)(a3 &gt;&gt; <span class="number">6</span>)) &amp; <span class="number">0x3F</span>];</span><br><span class="line">  result = dword_4128 + <span class="number">3</span>;</span><br><span class="line">  s1[result] = aAbcdefghijklmn[a3 &amp; <span class="number">0x3F</span>];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以知道，其实这就是Base64的加密，但是当我将“zMXHz9T6sdfZx8LtxZn0x8jHC8vFnJr3”丢进Base64之后会见到一坨不明所以的无意义字符串，所以要思考是不是遗漏了什么。</p><p>再次阅读代码，可以发现在加密前有一个不明函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub_1234();</span><br></pre></td></tr></table></figure><p>点进去我们可以看到如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_1234</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> k; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">8</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">25</span>; ++j )</span><br><span class="line">      result = sub_1169(&amp;aAbcdefghijklmn[j], &amp;aAbcdefghijklmn[j + <span class="number">26</span>]);</span><br><span class="line">    <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt;= <span class="number">5</span>; ++k )</span><br><span class="line">      result = sub_1169(&amp;aAbcdefghijklmn[k + <span class="number">52</span>], &amp;aAbcdefghijklmn[k + <span class="number">58</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现，参与加密操作的字符串aAbcdefghijklmn是被修改过的！！</p><p>里面还有一个修改的函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__fastcall <span class="title function_">sub_1169</span><span class="params">(<span class="type">char</span> *a1, <span class="type">char</span> *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v3; <span class="comment">// [rsp+1Fh] [rbp-1h]</span></span><br><span class="line"></span><br><span class="line">  v3 = *a1;</span><br><span class="line">  *a1 = *a2;</span><br><span class="line">  result = a2;</span><br><span class="line">  *a2 = v3;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个sub_1169函数的作用是交换a1和a2。</p><p>而直接查看内存，我们可以看到字符串aAbcdefghijklmn的值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aAbcdefghijklmn=<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br></pre></td></tr></table></figure><p>我们重写上面的C语言修改字符串代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> a[<span class="number">65</span>] = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">8</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">25</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> temp = a[j];</span><br><span class="line">            a[j] = a[j + <span class="number">26</span>];</span><br><span class="line">            a[j + <span class="number">26</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">5</span>; ++k )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> temp = a[k + <span class="number">52</span>];</span><br><span class="line">            a[k + <span class="number">52</span>] = a[k + <span class="number">58</span>];</span><br><span class="line">            a[k + <span class="number">58</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到aAbcdefghijklmn的新值为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aAbcdefghijklmn=<span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ6789+/012345&quot;</span></span><br></pre></td></tr></table></figure><p>我们上搜索引擎找到Base64解码算法（Python比较方便，所以用了Python）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">STANDARD_ALPHABET = <span class="string">b&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span><span class="comment">#标准加密表</span></span><br><span class="line">CUSTOM_ALPHABET = <span class="string">b&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ6789+/012345&#x27;</span><span class="comment">#修改后的加密表</span></span><br><span class="line">ENCODE_TRANS = <span class="built_in">bytes</span>.maketrans(STANDARD_ALPHABET, CUSTOM_ALPHABET)</span><br><span class="line">DECODE_TRANS = <span class="built_in">bytes</span>.maketrans(CUSTOM_ALPHABET, STANDARD_ALPHABET)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(<span class="built_in">input</span>).translate(ENCODE_TRANS)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    <span class="keyword">return</span> base64.b64decode(<span class="built_in">input</span>.translate(DECODE_TRANS))</span><br><span class="line"></span><br><span class="line">a=<span class="string">b&#x27;zMXHz9T6sdfZx8LtxZn0x8jHC8vFnJr3&#x27;</span><span class="comment">#密文</span></span><br><span class="line">destr = decode(a)</span><br><span class="line"><span class="built_in">print</span>(destr.decode())</span><br></pre></td></tr></table></figure><p>运行可得flag如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;tH1s_iS_3z_base_64&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Advanced-爱门"><a href="#Advanced-爱门" class="headerlink" title="[Advanced]爱门"></a>[Advanced]爱门</h2><p><del>（爱门✝）</del></p><p>先将它放进ida64反编译，进入main点击F5进行编译。</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938312.png" alt="main"></p><p>我们可以看到，获取flag的前置步骤是解出byte_4060，点进sub_134A函数，我们可以见到byte_4060被一定的规矩转换成了byte_40A0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sub_134A</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v0; <span class="comment">// r12</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = byte_4060[i];</span><br><span class="line">    byte_40A0[i] = v0 + aTheresa[i % <span class="built_in">strlen</span>(aTheresa)];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而参与了转换的函数为aTheresa<del>（一只德莉莎？）</del>，双击这个字符数组我们可以看到aTheresa的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aTheresa        db <span class="string">&#x27;Theresa&#x27;</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure><p>转换为C++我们可以知道：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string aTheresa=<span class="string">&quot;Theresa&quot;</span>;</span><br></pre></td></tr></table></figure><p>我们只知道这样一个类似维吉尼亚密码的密钥没有任何实质性作用，我们需要找出被加密后的字符串。点进main中的sub_1281函数，可以看到如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_1281</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+0h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = byte_4020[i];</span><br><span class="line">    <span class="keyword">if</span> ( byte_40A0[i] != (_BYTE)result )</span><br><span class="line">      dword_403C = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以见到，这边要得到byte_40A0，则需要先知道byte_4020是如何定义的，点开byte_4020我们可以看到它所在的那行是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte_4020       db <span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span></span><br></pre></td></tr></table></figure><p>它只有七个数据，但是byte_40A0需要26个数据，怎么办呢？</p><p>结合指针知识，数组的数据是存储在连续的地址里面的，如果一个指针指向一个数组，当指针指向的数组下标超过了数组范围时，它就会指向数组最后一个元素所在地址后面紧接着的地址，所以我们放大视野，就可以看到下面的数据：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938044.png" alt="data (2)"></p><p>刚刚好有26个数据，且跟其他的数据的地址没有冲突，所以用C++写下列代码进行解密的尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a1[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">196</span>, <span class="number">214</span>, <span class="number">202</span>, <span class="number">212</span>, <span class="number">197</span>, <span class="number">147</span>, <span class="number">167</span>, <span class="number">164</span>, <span class="number">177</span>, <span class="number">226</span>&#125;;</span><br><span class="line">string aTheresa = <span class="string">&quot;Theresa&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;(<span class="type">char</span>)(a1[i] - aTheresa[i % <span class="number">7</span>]);<span class="comment">//aTheresa的长度为7</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，我们可以得出下面一个看似合理的“flag”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;Elysia_is_dead????&#125;</span><br></pre></td></tr></table></figure><p><del>爱莉希雅死了？？？？</del></p><p>提交发现是错的，肯定是我们忽略了什么。</p><p>我们唯一没看过的就是左边的函数列了</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938479.png" alt="function_list"></p><p>这里有很多不知道是什么的函数，我们一个一个看，可以发现函数sub_12CE里面有修改上面的数组中数据的代码（变量命名对应）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">sub_12CE</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(byte_4060, <span class="number">0</span>, <span class="number">0x28</span>uLL);</span><br><span class="line">  result = <span class="built_in">memset</span>(byte_40A0, <span class="number">0</span>, <span class="keyword">sizeof</span>(byte_40A0));</span><br><span class="line">  byte_4030 = <span class="number">-45</span>;</span><br><span class="line">  byte_4031 = <span class="number">-103</span>;</span><br><span class="line">  byte_4032 = <span class="number">-39</span>;</span><br><span class="line">  byte_4033 = <span class="number">-46</span>;</span><br><span class="line">  byte_4034 = <span class="number">-59</span>;</span><br><span class="line">  byte_4035 = <span class="number">-71</span>;</span><br><span class="line">  byte_4036 = <span class="number">-55</span>;</span><br><span class="line">  byte_4037 = <span class="number">-55</span>;</span><br><span class="line">  byte_4038 = <span class="number">-109</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用此处代码对上述解密代码进行修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a1[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">196</span>, <span class="number">214</span>, <span class="number">202</span>, <span class="number">212</span>, <span class="number">197</span>, <span class="number">147</span>, <span class="number">167</span>, <span class="number">164</span>, <span class="number">177</span>, <span class="number">226</span>&#125;;<span class="comment">//修改前</span></span><br><span class="line"><span class="type">int</span> a2[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">-45</span>, <span class="number">-103</span>, <span class="number">-39</span>, <span class="number">-46</span>, <span class="number">-59</span>, <span class="number">-71</span>, <span class="number">-55</span>, <span class="number">-55</span>, <span class="number">-109</span>, <span class="number">226</span>&#125;;<span class="comment">//修改后</span></span><br><span class="line">string aTheresa = <span class="string">&quot;Theresa&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;(<span class="type">char</span>)(a2[i] - aTheresa[i % <span class="number">7</span>]);<span class="comment">//aTheresa的长度为7</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后又给出了一个看似合理的“flag”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;Elysia_isn&#x27;t_dead!&#125;</span><br></pre></td></tr></table></figure><p><del>爱莉希雅没有死！</del></p><p>提交发现，他还是错的。似乎我们还是有所遗漏。</p><p>继续把我们的目光放到函数列上，我们会发现，在main函数后，还有一个名为sub_144F的函数，它跟sub_12CE发挥的效果是相似的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_144F</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  byte_4027 = <span class="number">-121</span>;</span><br><span class="line">  byte_402B = <span class="number">-106</span>;</span><br><span class="line">  byte_402E += <span class="number">10</span>;</span><br><span class="line">  byte_402F -= <span class="number">31</span>;</span><br><span class="line">  byte_4030 = <span class="number">-106</span>;</span><br><span class="line">  byte_4031 = <span class="number">-34</span>;</span><br><span class="line">  byte_4032 -= <span class="number">8</span>;</span><br><span class="line">  byte_4034 -= <span class="number">3</span>;</span><br><span class="line">  byte_4035 = <span class="number">-64</span>;</span><br><span class="line">  byte_4036 = <span class="number">-47</span>;</span><br><span class="line">  byte_4037 = <span class="number">-69</span>;</span><br><span class="line">  byte_4038 = <span class="number">-41</span>;</span><br><span class="line">  dword_403C = <span class="number">1</span>;</span><br><span class="line">  sub_1281();</span><br><span class="line">  <span class="keyword">if</span> ( dword_403C == <span class="number">1</span> )</span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;Nice, job! U find it!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;What wrong with U? U didn&#x27;t find it! where is it?&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且我们可以发现它还判断了变量dword_403C的大小，通过前面的阅读，我们可以发现，dword_403C只有在输入的字符串是正确的flag的时候才是1，参考上面的代码对解密代码进行修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a1[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">196</span>, <span class="number">214</span>, <span class="number">202</span>, <span class="number">212</span>, <span class="number">197</span>, <span class="number">147</span>, <span class="number">167</span>, <span class="number">164</span>, <span class="number">177</span>, <span class="number">226</span>&#125;;<span class="comment">//修改前</span></span><br><span class="line"><span class="type">int</span> a2[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">153</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">189</span>, <span class="number">219</span>, <span class="number">-45</span>, <span class="number">-103</span>, <span class="number">-39</span>, <span class="number">-46</span>, <span class="number">-59</span>, <span class="number">-71</span>, <span class="number">-55</span>, <span class="number">-55</span>, <span class="number">-109</span>, <span class="number">226</span>&#125;;<span class="comment">//一次修改后</span></span><br><span class="line"><span class="type">int</span> a3[<span class="number">26</span>] = &#123;<span class="number">149</span>, <span class="number">221</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">215</span>, <span class="number">212</span>, <span class="number">220</span>, <span class="number">-121</span>, <span class="number">212</span>, <span class="number">222</span>, <span class="number">229</span>, <span class="number">-106</span>, <span class="number">212</span>, <span class="number">192</span>, <span class="number">199</span>, <span class="number">188</span>, <span class="number">-106</span>, <span class="number">-34</span>, <span class="number">-47</span>, <span class="number">-46</span>, <span class="number">-62</span>, <span class="number">-64</span>, <span class="number">-47</span>, <span class="number">-69</span>, <span class="number">-41</span>, <span class="number">226</span>&#125;;<span class="comment">//二次修改后</span></span><br><span class="line">string aTheresa = <span class="string">&quot;Theresa&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;(<span class="type">char</span>)(a3[i] - aTheresa[i % <span class="number">7</span>]);<span class="comment">//aTheresa的长度为7</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，我们可以得到如下flag：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aurora&#123;3lys1a_sT1ll_aliVe&#125;</span><br></pre></td></tr></table></figure><p><del>爱莉希雅还活着</del></p><p>提交发现这个是真正的flag，至此，我们就解决了这道题。</p><hr><h2 id="Block-Chain"><a href="#Block-Chain" class="headerlink" title="Block Chain"></a>Block Chain</h2><hr><h2 id="easy-契约"><a href="#easy-契约" class="headerlink" title="[easy]契约"></a>[easy]契约</h2><p>这题利用的是合约创建字节码泄露。</p><p><del>需要挂梯子</del></p><p>进入网站：<a href="https://sepolia.etherscan.io/">TESTNET Sepolia (ETH) Blockchain Explorer (etherscan.io)</a></p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938033.png" alt="Exploer"></p><p>在搜索框中输入题中给出合约并搜索：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111938458.png" alt="heyue"></p><p>点进合约对应的交易之后找到“Input data”一栏，在“View input as”处选择“UTF-8”就可以看到这样一坨：</p><p><img src="https://cdn.jsdelivr.net/gh/TriodeLzx/blogimage/blog202311111935175.png" alt="flag"></p><p>里面蕴含了我们要的flag：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;W3lc0me_2_Blockch4in!!!&#125;</span><br></pre></td></tr></table></figure><p>注意：在提交的时候，flag的最后可能有一个不可见字符，需要删掉。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Crypto&quot;&gt;&lt;a href=&quot;#Crypto&quot; class=&quot;headerlink&quot; title=&quot;Crypto&quot;&gt;&lt;/a&gt;Crypto&lt;/h2&gt;&lt;hr&gt;
&lt;h2 id=&quot;简单丢番图方程（解题成本最高的一道）&quot;&gt;&lt;a href=&quot;#简单丢番图方程（解题成本最高</summary>
      
    
    
    
    <category term="信安WP" scheme="https://triodelzx.github.io/categories/%E4%BF%A1%E5%AE%89WP/"/>
    
    
  </entry>
  
</feed>
